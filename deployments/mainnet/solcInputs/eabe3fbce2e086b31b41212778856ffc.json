{
  "language": "Solidity",
  "sources": {
    "contracts/access/AccessControl/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/1488d4f6782f76f74f3652e44da9b9e241146ccb/contracts/access/AccessControl.sol\n *\n * Changes:\n * - Compiled for 0.7.6\n * - Removed ERC165 Introspection\n * - Removed _checkRole\n * - Reformatted styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity ^0.7.6;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\nimport \"../interfaces/IAccessControl.sol\";\n\nabstract contract AccessControl is Context, IAccessControl {\n\tstruct RoleData {\n\t\tmapping(address => bool) members;\n\t\tbytes32 adminRole;\n\t}\n\n\tmapping(bytes32 => RoleData) private _roles;\n\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\t/* Modifiers */\n\n\tmodifier onlyRole(bytes32 role) {\n\t\trequire(hasRole(role, _msgSender()), \"AccessControl: access denied\");\n\t\t_;\n\t}\n\n\t/* External Views */\n\n\t/**\n\t * @dev Returns `true` if `account` has been granted `role`.\n\t */\n\tfunction hasRole(bytes32 role, address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _roles[role].members[account];\n\t}\n\n\t/**\n\t * @dev Returns the admin role that controls `role`. See {grantRole} and\n\t * {revokeRole}.\n\t *\n\t * To change a role's admin, use {_setRoleAdmin}.\n\t */\n\tfunction getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n\t\treturn _roles[role].adminRole;\n\t}\n\n\t/* External Mutators */\n\n\t/**\n\t * @dev Grants `role` to `account`.\n\t *\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\n\t * event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have ``role``'s admin role.\n\t */\n\tfunction grantRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_grantRole(role, account);\n\t}\n\n\t/**\n\t * @dev Revokes `role` from `account`.\n\t *\n\t * If `account` had been granted `role`, emits a {RoleRevoked} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have ``role``'s admin role.\n\t */\n\tfunction revokeRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_revokeRole(role, account);\n\t}\n\n\t/**\n\t * @dev Revokes `role` from the calling account.\n\t *\n\t * Roles are often managed via {grantRole} and {revokeRole}: this function's\n\t * purpose is to provide a mechanism for accounts to lose their privileges\n\t * if they are compromised (such as when a trusted device is misplaced).\n\t *\n\t * If the calling account had been granted `role`, emits a {RoleRevoked}\n\t * event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must be `account`.\n\t */\n\tfunction renounceRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(\n\t\t\taccount == _msgSender(),\n\t\t\t\"AccessControl: can only renounce roles for self\"\n\t\t);\n\n\t\t_revokeRole(role, account);\n\t}\n\n\t/* Internal Mutators */\n\n\t/**\n\t * @dev Grants `role` to `account`.\n\t *\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\n\t * event. Note that unlike {grantRole}, this function doesn't perform any\n\t * checks on the calling account.\n\t *\n\t * [WARNING]\n\t * ====\n\t * This function should only be called from the constructor when setting\n\t * up the initial roles for the system.\n\t *\n\t * Using this function in any other way is effectively circumventing the admin\n\t * system imposed by {AccessControl}.\n\t * ====\n\t */\n\tfunction _setupRole(bytes32 role, address account) internal virtual {\n\t\t_grantRole(role, account);\n\t}\n\n\t/**\n\t * @dev Sets `adminRole` as ``role``'s admin role.\n\t *\n\t * Emits a {RoleAdminChanged} event.\n\t */\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\t\temit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n\t\t_roles[role].adminRole = adminRole;\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) private {\n\t\tif (!hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) private {\n\t\tif (hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/access/interfaces/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IAccessControl {\n\t/* Views */\n\n\tfunction getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n\tfunction hasRole(bytes32 role, address account) external view returns (bool);\n\n\t/* Mutators */\n\n\tfunction grantRole(bytes32 role, address account) external;\n\n\tfunction revokeRole(bytes32 role, address account) external;\n\n\tfunction renounceRole(bytes32 role, address account) external;\n\n\t/* Events */\n\tevent RoleAdminChanged(\n\t\tbytes32 indexed role,\n\t\tbytes32 indexed previousAdminRole,\n\t\tbytes32 indexed newAdminRole\n\t);\n\tevent RoleGranted(\n\t\tbytes32 indexed role,\n\t\taddress indexed account,\n\t\taddress indexed sender\n\t);\n\tevent RoleRevoked(\n\t\tbytes32 indexed role,\n\t\taddress indexed account,\n\t\taddress indexed sender\n\t);\n}\n"
    },
    "contracts/oracles/Policy.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../access/AccessControl/AccessControl.sol\";\n\ninterface IGasPrice {\n\tfunction setGasPrice(uint256) external;\n}\n\ninterface IETHtx {\n\tfunction rebase() external;\n}\n\ncontract Policy is AccessControl {\n\tbytes32 public constant POLICY_ROLE = keccak256(\"POLICY_ROLE\");\n\n\taddress public immutable ethtx;\n\taddress public immutable gasOracle;\n\n\tconstructor(\n\t\taddress admin,\n\t\taddress policyMaker,\n\t\taddress gasOracle_,\n\t\taddress ethtx_\n\t) {\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, admin);\n\t\t_setupRole(POLICY_ROLE, policyMaker);\n\t\tethtx = ethtx_;\n\t\tgasOracle = gasOracle_;\n\t}\n\n\tfunction update(uint256 gasPrice) external onlyRole(POLICY_ROLE) {\n\t\tIGasPrice(gasOracle).setGasPrice(gasPrice);\n\t\tIETHtx(ethtx).rebase();\n\t}\n}\n"
    },
    "contracts/access/RbacFromOwnable/RbacFromOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * From https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/aeb86bf4f438e0fedb5eecc3dd334fd6544ab1f6/contracts/access/AccessControlUpgradeable.sol\n *\n * Changes:\n * - Compiled for 0.7.6\n * - Removed ERC165 Introspection\n * - Moved state to RbacFromOwnableData\n * - Added _ownerDeprecated for upgrading from OwnableUpgradeable\n * - Removed _checkRole\n * - Reformatted styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"./RbacFromOwnableData.sol\";\nimport \"../interfaces/IAccessControl.sol\";\n\n/* solhint-disable func-name-mixedcase */\n\nabstract contract RbacFromOwnable is\n\tInitializable,\n\tContextUpgradeable,\n\tRbacFromOwnableData,\n\tIAccessControl\n{\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\t/* Initializer */\n\n\tfunction __RbacFromOwnable_init() internal initializer {\n\t\t__Context_init_unchained();\n\t}\n\n\tfunction __RbacFromOwnable_init_unchained() internal initializer {\n\t\treturn;\n\t}\n\n\t/* Modifiers */\n\n\tmodifier onlyRole(bytes32 role) {\n\t\trequire(hasRole(role, _msgSender()), \"AccessControl: access denied\");\n\t\t_;\n\t}\n\n\t/* External Views */\n\n\tfunction hasRole(bytes32 role, address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _roles[role].members[account];\n\t}\n\n\tfunction getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n\t\treturn _roles[role].adminRole;\n\t}\n\n\t/* External Mutators */\n\n\tfunction grantRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_grantRole(role, account);\n\t}\n\n\tfunction revokeRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_revokeRole(role, account);\n\t}\n\n\tfunction renounceRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(\n\t\t\taccount == _msgSender(),\n\t\t\t\"AccessControl: can only renounce roles for self\"\n\t\t);\n\n\t\t_revokeRole(role, account);\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _setupRole(bytes32 role, address account) internal virtual {\n\t\t_grantRole(role, account);\n\t}\n\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\t\temit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n\t\t_roles[role].adminRole = adminRole;\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) private {\n\t\tif (!hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) private {\n\t\tif (hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\nimport \"../proxy/Initializable.sol\";\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity >=0.4.24 <0.8.0;\n\nimport \"../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/access/RbacFromOwnable/RbacFromOwnableData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract RbacFromOwnableData {\n\tstruct RoleData {\n\t\tmapping(address => bool) members;\n\t\tbytes32 adminRole;\n\t}\n\n\taddress internal _ownerDeprecated;\n\n\tmapping(bytes32 => RoleData) internal _roles;\n\n\tuint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tokens/ETHtx/ETHtx.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ETHtxData.sol\";\nimport \"../ERC20/ERC20Data.sol\";\nimport \"../ERC20TxFee/ERC20TxFeeData.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IETHtx.sol\";\nimport \"../../rewards/interfaces/IFeeLogic.sol\";\nimport \"../../access/RbacFromOwnable/RbacFromOwnable.sol\";\n\n/* solhint-disable not-rely-on-time */\n\ncontract ETHtx is\n\tInitializable,\n\tContextUpgradeable,\n\tRbacFromOwnable,\n\tPausableUpgradeable,\n\tERC20Data,\n\tERC20TxFeeData,\n\tETHtxData,\n\tIERC20,\n\tIERC20Metadata,\n\tIETHtx\n{\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\tstruct ETHtxArgs {\n\t\taddress feeLogic;\n\t\taddress[] minters;\n\t\taddress[] rebasers;\n\t}\n\n\tbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\tbytes32 public constant REBASER_ROLE = keccak256(\"REBASER_ROLE\");\n\n\tuint256 internal constant _SHARES_MULT = 1e18;\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializer */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Pausable_init_unchained();\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, owner_);\n\t}\n\n\tfunction postInit(ETHtxArgs memory _args)\n\t\texternal\n\t\tvirtual\n\t\tonlyRole(DEFAULT_ADMIN_ROLE)\n\t{\n\t\taddress sender = _msgSender();\n\n\t\t_feeLogic = _args.feeLogic;\n\t\temit FeeLogicSet(sender, _args.feeLogic);\n\n\t\tfor (uint256 i = 0; i < _args.minters.length; i++) {\n\t\t\t_setupRole(MINTER_ROLE, _args.minters[i]);\n\t\t}\n\n\t\tfor (uint256 i = 0; i < _args.rebasers.length; i++) {\n\t\t\t_setupRole(REBASER_ROLE, _args.rebasers[i]);\n\t\t}\n\n\t\t_sharesPerToken = _SHARES_MULT;\n\t}\n\n\tfunction postUpgrade(address feeLogic_, address[] memory rebasers)\n\t\texternal\n\t\tvirtual\n\t{\n\t\taddress sender = _msgSender();\n\t\t// Can only be called once\n\t\trequire(\n\t\t\t_ownerDeprecated == sender,\n\t\t\t\"ETHtx::postUpgrade: caller is not the owner\"\n\t\t);\n\n\t\t_feeLogic = feeLogic_;\n\t\temit FeeLogicSet(sender, feeLogic_);\n\n\t\t// Set sharesPerToken to 1:1\n\t\t_totalShares = _totalSupply;\n\t\t_sharesPerToken = _SHARES_MULT;\n\n\t\t// Setup RBAC\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, sender);\n\t\t_setupRole(MINTER_ROLE, _minterDeprecated);\n\t\tfor (uint256 i = 0; i < rebasers.length; i++) {\n\t\t\t_setupRole(REBASER_ROLE, rebasers[i]);\n\t\t}\n\n\t\t// Clear deprecated state\n\t\t_minterDeprecated = address(0);\n\t\t_ownerDeprecated = address(0);\n\t}\n\n\t/* External Mutators */\n\n\tfunction transfer(address recipient, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(\n\t\t\tsender,\n\t\t\t_msgSender(),\n\t\t\t_allowances[sender][_msgSender()].sub(\n\t\t\t\tamount,\n\t\t\t\t\"ETHtx::transferFrom: amount exceeds allowance\"\n\t\t\t)\n\t\t);\n\t\treturn true;\n\t}\n\n\tfunction approve(address spender, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\tfunction increaseAllowance(address spender, uint256 addedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].add(addedValue)\n\t\t);\n\t\treturn true;\n\t}\n\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].sub(\n\t\t\t\tsubtractedValue,\n\t\t\t\t\"ETHtx::decreaseAllowance: below zero\"\n\t\t\t)\n\t\t);\n\t\treturn true;\n\t}\n\n\tfunction burn(address account, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(MINTER_ROLE)\n\t\twhenNotPaused\n\t{\n\t\t_burn(account, amount);\n\t}\n\n\tfunction mint(address account, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(MINTER_ROLE)\n\t\twhenNotPaused\n\t{\n\t\t_mint(account, amount);\n\t}\n\n\tfunction pause()\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(DEFAULT_ADMIN_ROLE)\n\t\twhenNotPaused\n\t{\n\t\t_pause();\n\t}\n\n\tfunction rebase()\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(REBASER_ROLE)\n\t\twhenNotPaused\n\t{\n\t\t// Limit calls\n\t\tuint256 timePassed =\n\t\t\tblock.timestamp.sub(\n\t\t\t\t_lastRebaseTime,\n\t\t\t\t\"ETHtx::rebase: block is older than last rebase\"\n\t\t\t);\n\t\tIFeeLogic feeHandle = IFeeLogic(_feeLogic);\n\t\trequire(\n\t\t\ttimePassed >= feeHandle.rebaseInterval(),\n\t\t\t\"ETHtx::rebase: too soon\"\n\t\t);\n\n\t\tuint256 initTotalShares = _totalShares;\n\t\tif (initTotalShares == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t(uint128 rebaseNum, uint128 rebaseDen) = feeHandle.rebaseFeeRate();\n\n\t\t// WARN This will eventually overflow\n\t\tuint256 ts = initTotalShares.mul(rebaseDen) / (rebaseDen - rebaseNum);\n\t\tuint256 newShares = ts - initTotalShares;\n\n\t\t// Send to exemptions to return them to their initial percentage\n\t\tfor (uint256 i = 0; i < feeHandle.rebaseExemptsLength(); i++) {\n\t\t\taddress exempt = feeHandle.rebaseExemptsAt(i);\n\t\t\tuint256 balance = _balances[exempt];\n\t\t\tif (balance != 0) {\n\t\t\t\tuint256 newBalance = balance.mul(rebaseDen) / (rebaseDen - rebaseNum);\n\t\t\t\tuint256 addedShares = newBalance - balance;\n\t\t\t\t_balances[exempt] = newBalance;\n\t\t\t\tnewShares -= addedShares;\n\t\t\t}\n\t\t}\n\t\tassert(newShares < ts);\n\n\t\t// Send the remainder to rewards\n\t\taddress rewardsRecipient = feeHandle.recipient();\n\t\t_balances[rewardsRecipient] = _balances[rewardsRecipient].add(newShares);\n\n\t\t// Mint shares, reducing every holder's percentage\n\t\t_totalShares = ts;\n\t\t// WARN This will eventually overflow\n\t\t_sharesPerToken = ts.mul(_SHARES_MULT).div(_totalSupply);\n\n\t\t_lastRebaseTime = block.timestamp;\n\n\t\temit Rebased(_msgSender(), ts);\n\t}\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyRole(DEFAULT_ADMIN_ROLE) {\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit Recovered(_msgSender(), token, to, amount);\n\t}\n\n\tfunction setFeeLogic(address account)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(DEFAULT_ADMIN_ROLE)\n\t{\n\t\trequire(account != address(0), \"ETHtx::setFeeLogic: zero address\");\n\t\t_feeLogic = account;\n\t\temit FeeLogicSet(_msgSender(), account);\n\t}\n\n\tfunction unpause()\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(DEFAULT_ADMIN_ROLE)\n\t\twhenPaused\n\t{\n\t\t_unpause();\n\t}\n\n\t/* External Views */\n\n\tfunction allowance(address owner, address spender)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _allowances[owner][spender];\n\t}\n\n\tfunction balanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _balances[account].mul(_SHARES_MULT).div(_sharesPerToken);\n\t}\n\n\tfunction sharesBalanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _balances[account];\n\t}\n\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn \"Ethereum Transaction\";\n\t}\n\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn \"ETHtx\";\n\t}\n\n\tfunction decimals() public view virtual override returns (uint8) {\n\t\treturn 18;\n\t}\n\n\tfunction feeLogic() public view virtual override returns (address) {\n\t\treturn _feeLogic;\n\t}\n\n\tfunction lastRebaseTime() public view virtual override returns (uint256) {\n\t\treturn _lastRebaseTime;\n\t}\n\n\tfunction sharesPerTokenX18()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _sharesPerToken;\n\t}\n\n\tfunction totalShares() public view virtual override returns (uint256) {\n\t\treturn _totalShares;\n\t}\n\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(owner != address(0), \"ETHtx::_approve: from the zero address\");\n\t\trequire(spender != address(0), \"ETHtx::_approve: to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev Implements an ERC20 transfer with a fee.\n\t *\n\t * Emits a {Transfer} event. Emits a second {Transfer} event for the fee.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - `_feeLogic` implements {IFeeLogic}\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(sender != address(0), \"ETHtx::_transfer: from the zero address\");\n\t\trequire(recipient != address(0), \"ETHtx::_transfer: to the zero address\");\n\n\t\tuint256 spt = _sharesPerToken;\n\t\trequire(spt != 0, \"ETHtx::_transfer: zero sharesPerToken\");\n\n\t\t// Could round small values to zero\n\t\tuint256 shares = amount.mul(spt).div(_SHARES_MULT);\n\n\t\t_balances[sender] = _balances[sender].sub(\n\t\t\tshares,\n\t\t\t\"ETHtx::_transfer: amount exceeds balance\"\n\t\t);\n\n\t\tIFeeLogic feeHandler = IFeeLogic(_feeLogic);\n\t\tuint256 fee = feeHandler.getFee(sender, recipient, shares);\n\t\tuint256 sharesSubFee = shares.sub(fee);\n\n\t\t_balances[recipient] = _balances[recipient].add(sharesSubFee);\n\t\temit Transfer(sender, recipient, (sharesSubFee * _SHARES_MULT) / spt);\n\n\t\tif (fee != 0) {\n\t\t\taddress feeRecipient = feeHandler.recipient();\n\t\t\t_balances[feeRecipient] = _balances[feeRecipient].add(fee);\n\n\t\t\tuint256 feeInTokens = (fee * _SHARES_MULT) / spt;\n\t\t\temit Transfer(sender, feeRecipient, feeInTokens);\n\t\t\tfeeHandler.notify(feeInTokens);\n\t\t}\n\t}\n\n\tfunction _burn(address account, uint256 amount) internal {\n\t\t// Burn shares proportionately for constant _sharesPerToken\n\t\tuint256 shares = amount.mul(_sharesPerToken) / _SHARES_MULT;\n\t\t_balances[account] = _balances[account].sub(\n\t\t\tshares,\n\t\t\t\"ETHtx::_burn: amount exceeds balance\"\n\t\t);\n\t\t_totalShares = _totalShares.sub(shares);\n\t\t// Burn tokens\n\t\t_totalSupply = _totalSupply.sub(amount);\n\n\t\temit Transfer(account, address(0), amount);\n\t}\n\n\tfunction _mint(address account, uint256 amount) internal {\n\t\t// Mint shares proportionately for constant _sharesPerToken\n\t\tuint256 shares = amount.mul(_sharesPerToken) / _SHARES_MULT;\n\t\t_totalShares = _totalShares.add(shares);\n\t\t_balances[account] = _balances[account].add(shares);\n\t\t// Mint tokens\n\t\t_totalSupply = _totalSupply.add(amount);\n\n\t\temit Transfer(address(0), account, amount);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./ContextUpgradeable.sol\";\nimport \"../proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal initializer {\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal initializer {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/tokens/ETHtx/ETHtxData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ETHtxData {\n\taddress internal _minterDeprecated;\n\n\tuint256 internal _sharesPerToken;\n\tuint256 internal _totalShares;\n\n\tuint256 internal _lastRebaseTime;\n\n\tuint256[46] private __gap;\n}\n"
    },
    "contracts/tokens/ERC20/ERC20Data.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ERC20Data {\n\tmapping(address => uint256) internal _balances;\n\tmapping(address => mapping(address => uint256)) internal _allowances;\n\tuint256 internal _totalSupply;\n\tuint256[47] private __gap;\n}\n"
    },
    "contracts/tokens/ERC20TxFee/ERC20TxFeeData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ERC20TxFeeData {\n\taddress internal _feeLogic;\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.7.6;\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata {\n\t/**\n\t * @dev Returns the name of the token.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the symbol of the token.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the decimals places of the token.\n\t */\n\tfunction decimals() external view returns (uint8);\n}\n"
    },
    "contracts/tokens/interfaces/IETHtx.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IETHtx {\n\t/* Views */\n\n\tfunction feeLogic() external view returns (address);\n\n\tfunction lastRebaseTime() external view returns (uint256);\n\n\tfunction sharesBalanceOf(address account) external view returns (uint256);\n\n\tfunction sharesPerTokenX18() external view returns (uint256);\n\n\tfunction totalShares() external view returns (uint256);\n\n\t/* Mutators */\n\n\tfunction burn(address account, uint256 amount) external;\n\n\tfunction mint(address account, uint256 amount) external;\n\n\tfunction pause() external;\n\n\tfunction rebase() external;\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction setFeeLogic(address account) external;\n\n\tfunction unpause() external;\n\n\t/* Events */\n\n\tevent FeeLogicSet(address indexed author, address indexed account);\n\tevent Rebased(address indexed author, uint256 totalShares);\n\tevent Recovered(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n}\n"
    },
    "contracts/rewards/interfaces/IFeeLogic.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IFeeLogic {\n\t/* Types */\n\n\tstruct ExemptData {\n\t\taddress account;\n\t\tbool isExempt;\n\t}\n\n\t/* Views */\n\n\tfunction exemptsAt(uint256 index) external view returns (address);\n\n\tfunction exemptsLength() external view returns (uint256);\n\n\tfunction feeRate()\n\t\texternal\n\t\tview\n\t\treturns (uint128 numerator, uint128 denominator);\n\n\tfunction getFee(\n\t\taddress sender,\n\t\taddress recipient_,\n\t\tuint256 amount\n\t) external view returns (uint256);\n\n\tfunction getRebaseFee(uint256 amount) external view returns (uint256);\n\n\tfunction isExempt(address account) external view returns (bool);\n\n\tfunction isRebaseExempt(address account) external view returns (bool);\n\n\tfunction rebaseExemptsAt(uint256 index) external view returns (address);\n\n\tfunction rebaseExemptsLength() external view returns (uint256);\n\n\tfunction rebaseFeeRate()\n\t\texternal\n\t\tview\n\t\treturns (uint128 numerator, uint128 denominator);\n\n\tfunction rebaseInterval() external view returns (uint256);\n\n\tfunction recipient() external view returns (address);\n\n\tfunction undoFee(\n\t\taddress sender,\n\t\taddress recipient_,\n\t\tuint256 amount\n\t) external view returns (uint256);\n\n\tfunction undoRebaseFee(uint256 amount) external view returns (uint256);\n\n\t/* Mutators */\n\n\tfunction notify(uint256 amount) external;\n\n\tfunction setExempt(address account, bool isExempt_) external;\n\n\tfunction setExemptBatch(ExemptData[] memory batch) external;\n\n\tfunction setFeeRate(uint128 numerator, uint128 denominator) external;\n\n\tfunction setRebaseExempt(address account, bool isExempt_) external;\n\n\tfunction setRebaseExemptBatch(ExemptData[] memory batch) external;\n\n\tfunction setRebaseFeeRate(uint128 numerator, uint128 denominator) external;\n\n\tfunction setRebaseInterval(uint256 interval) external;\n\n\tfunction setRecipient(address account) external;\n\n\t/* Events */\n\n\tevent ExemptAdded(address indexed author, address indexed account);\n\tevent ExemptRemoved(address indexed author, address indexed account);\n\tevent FeeRateSet(\n\t\taddress indexed author,\n\t\tuint128 numerator,\n\t\tuint128 denominator\n\t);\n\tevent RebaseExemptAdded(address indexed author, address indexed account);\n\tevent RebaseExemptRemoved(address indexed author, address indexed account);\n\tevent RebaseFeeRateSet(\n\t\taddress indexed author,\n\t\tuint128 numerator,\n\t\tuint128 denominator\n\t);\n\tevent RebaseIntervalSet(address indexed author, uint256 interval);\n\tevent RecipientSet(address indexed author, address indexed account);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tokens/mocks/MockETHtx.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../ETHtx/ETHtx.sol\";\n\ncontract MockETHtx is ETHtx {\n\tusing SafeMath for uint256;\n\n\tconstructor(address owner_) ETHtx(owner_) {\n\t\treturn;\n\t}\n\n\tfunction mockMint(address account, uint256 amount) external {\n\t\t_mint(account, amount);\n\t}\n\n\tfunction mockMintShares(address account, uint256 amount) external {\n\t\tuint256 ts = _totalShares.add(amount);\n\t\t_totalShares = ts;\n\t\t_sharesPerToken = ts.mul(_SHARES_MULT).div(_totalSupply);\n\t\t_balances[account] = _balances[account].add(amount);\n\t}\n\n\tfunction mockBurn(address account, uint256 amount) external {\n\t\t_burn(account, amount);\n\t}\n\n\tfunction mockBurnShares(address account, uint256 amount) external {\n\t\t_balances[account] = _balances[account].sub(amount);\n\t\tuint256 ts = _totalShares.sub(amount);\n\t\t_totalShares = ts;\n\t\t_sharesPerToken = ts.mul(_SHARES_MULT).div(_totalSupply);\n\t}\n}\n"
    },
    "contracts/tokens/ERC20TxFee/ERC20TxFeeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"./ERC20TxFeeData.sol\";\nimport \"../ERC20/ERC20Upgradeable.sol\";\nimport \"../interfaces/IERC20TxFee.sol\";\nimport \"../../rewards/interfaces/IFeeLogic.sol\";\n\ncontract ERC20TxFeeUpgradeable is\n\tInitializable,\n\tContextUpgradeable,\n\tERC20Upgradeable,\n\tERC20TxFeeData,\n\tIERC20TxFee\n{\n\tusing SafeMath for uint256;\n\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction __ERC20TxFee_init(address feeLogic_) internal initializer {\n\t\t__ERC20_init();\n\t\t__ERC20TxFee_init_unchained(feeLogic_);\n\t}\n\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction __ERC20TxFee_init_unchained(address feeLogic_)\n\t\tinternal\n\t\tinitializer\n\t{\n\t\trequire(feeLogic_ != address(0), \"ERC20TxFee: feeLogic zero address\");\n\t\t__ERC20_init_unchained();\n\t\t_feeLogic = feeLogic_;\n\t}\n\n\t/* Public Views */\n\n\t/**\n\t * @dev Returns the feeLogic handler address.\n\t */\n\tfunction feeLogic() public view virtual override returns (address) {\n\t\treturn _feeLogic;\n\t}\n\n\t/* Internal Mutators */\n\n\t/**\n\t * @dev Overrides {ERC20-_transfer} to implement a fee on transfers.\n\t *\n\t * Emits a {Transfer} event. Emits a second {Transfer} event for the fee.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - `_feeLogic` implements {IFeeLogic}\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\t_balances[sender] = _balances[sender].sub(\n\t\t\tamount,\n\t\t\t\"ERC20: transfer amount exceeds balance\"\n\t\t);\n\n\t\tIFeeLogic feeHandler = IFeeLogic(_feeLogic);\n\t\tuint256 fee = feeHandler.getFee(sender, recipient, amount);\n\t\tuint256 amountSubFee = amount.sub(fee);\n\n\t\t_balances[recipient] = _balances[recipient].add(amountSubFee);\n\t\temit Transfer(sender, recipient, amountSubFee);\n\n\t\tif (fee != 0) {\n\t\t\taddress feeRecipient = feeHandler.recipient();\n\t\t\t_balances[feeRecipient] = _balances[feeRecipient].add(fee);\n\t\t\temit Transfer(sender, feeRecipient, fee);\n\t\t\tfeeHandler.notify(fee);\n\t\t}\n\t}\n}\n"
    },
    "contracts/tokens/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0-solc-0.7/contracts/token/ERC20/ERC20.sol\n *\n * Changes:\n * - Move state to abstract data contract\n * - Change _balances, _allowances, and _totalSupply from private to internal\n * - Replace name, symbol, and decimals state with virtual functions.\n * - Make all functions virtual\n * - Reformat styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ERC20Data.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is\n\tInitializable,\n\tContextUpgradeable,\n\tERC20Data,\n\tIERC20\n{\n\tusing SafeMath for uint256;\n\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction __ERC20_init() internal initializer {\n\t\t__Context_init_unchained();\n\t\t__ERC20_init_unchained();\n\t}\n\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction __ERC20_init_unchained() internal initializer {\n\t\treturn;\n\t}\n\n\t/**\n\t * @dev Returns the name of the token. Overload it to change.\n\t */\n\tfunction name() public view virtual returns (string memory) {\n\t\treturn \"ERC20\";\n\t}\n\n\t/**\n\t * @dev Returns the symbol of the token, usually a shorter version of the\n\t * name. Overload it to change.\n\t */\n\tfunction symbol() public view virtual returns (string memory) {\n\t\treturn \"ERC20\";\n\t}\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * Tokens usually opt for a value of 18, imitating the relationship between\n\t * Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t * overridden;\n\t *\n\t * NOTE: This information is only used for _display_ purposes: it in\n\t * no way affects any of the arithmetic of the contract, including\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\n\t */\n\tfunction decimals() public view virtual returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {IERC20-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {IERC20-balanceOf}.\n\t */\n\tfunction balanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Requirements:\n\t *\n\t * - `recipient` cannot be the zero address.\n\t * - the caller must have a balance of at least `amount`.\n\t */\n\tfunction transfer(address recipient, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-allowance}.\n\t */\n\tfunction allowance(address owner, address spender)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev See {IERC20-approve}.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction approve(address spender, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP. See the note at the beginning of {ERC20}.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` and `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - the caller must have allowance for ``sender``'s tokens of at least\n\t * `amount`.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(\n\t\t\tsender,\n\t\t\t_msgSender(),\n\t\t\t_allowances[sender][_msgSender()].sub(\n\t\t\t\tamount,\n\t\t\t\t\"ERC20: transfer amount exceeds allowance\"\n\t\t\t)\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically increases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].add(addedValue)\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t * - `spender` must have allowance for the caller of at least\n\t * `subtractedValue`.\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].sub(\n\t\t\t\tsubtractedValue,\n\t\t\t\t\"ERC20: decreased allowance below zero\"\n\t\t\t)\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves tokens `amount` from `sender` to `recipient`.\n\t *\n\t * This is internal function is equivalent to {transfer}, and can be used to\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\t_balances[sender] = _balances[sender].sub(\n\t\t\tamount,\n\t\t\t\"ERC20: transfer amount exceeds balance\"\n\t\t);\n\n\t\t_balances[recipient] = _balances[recipient].add(amount);\n\n\t\temit Transfer(sender, recipient, amount);\n\t}\n\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t */\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\n\t\t_totalSupply = _totalSupply.add(amount);\n\t\t_balances[account] = _balances[account].add(amount);\n\t\temit Transfer(address(0), account, amount);\n\t}\n\n\t/**\n\t * @dev Destroys `amount` tokens from `account`, reducing the\n\t * total supply.\n\t *\n\t * Emits a {Transfer} event with `to` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t * - `account` must have at least `amount` tokens.\n\t */\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\t_balances[account] = _balances[account].sub(\n\t\t\tamount,\n\t\t\t\"ERC20: burn amount exceeds balance\"\n\t\t);\n\n\t\t_totalSupply = _totalSupply.sub(amount);\n\n\t\temit Transfer(account, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n\t *\n\t * This internal function is equivalent to `approve`, and can be used to\n\t * e.g. set automatic allowances for certain subsystems, etc.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev Hook that is called before any transfer of tokens. This includes\n\t * minting and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\t * will be to transferred to `to`.\n\t * - when `from` is zero, `amount` tokens will be minted for `to`.\n\t * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts. adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress, /* from */\n\t\taddress, /* to */\n\t\tuint256 /* amount */\n\t) internal virtual {\n\t\treturn;\n\t}\n}\n"
    },
    "contracts/tokens/interfaces/IERC20TxFee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IERC20TxFee {\n\t/* Views */\n\n\tfunction feeLogic() external view returns (address);\n}\n"
    },
    "contracts/tokens/mocks/ETHtx/ETHtx_v1_0_0.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./ETHtxData_v1_0_0.sol\";\nimport \"./IETHtx_v1_0_0.sol\";\nimport \"../../ERC20TxFee/ERC20TxFeeUpgradeable.sol\";\nimport \"../../../access/OwnableUpgradeable.sol\";\n\n/* solhint-disable-next-line contract-name-camelcase */\ncontract ETHtx_v1_0_0 is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tPausableUpgradeable,\n\tERC20TxFeeUpgradeable,\n\tETHtxData_v1_0_0,\n\tIETHtx_v1_0_0\n{\n\tusing SafeERC20 for IERC20;\n\n\tstruct ETHtxArgs {\n\t\taddress feeLogic;\n\t\taddress minter;\n\t}\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializer */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t\t__Pausable_init_unchained();\n\t}\n\n\tfunction postInit(ETHtxArgs memory _args) external virtual onlyOwner {\n\t\taddress sender = _msgSender();\n\n\t\t_feeLogic = _args.feeLogic;\n\t\temit FeeLogicSet(sender, _args.feeLogic);\n\n\t\t_minter = _args.minter;\n\t\temit MinterSet(sender, _args.minter);\n\t}\n\n\t/* Modifiers */\n\n\tmodifier onlyMinter {\n\t\trequire(_msgSender() == minter(), \"ETHtx: caller is not the minter\");\n\t\t_;\n\t}\n\n\t/* External Mutators */\n\n\tfunction burn(address account, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyMinter\n\t\twhenNotPaused\n\t{\n\t\t_burn(account, amount);\n\t}\n\n\tfunction mint(address account, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyMinter\n\t\twhenNotPaused\n\t{\n\t\t_mint(account, amount);\n\t}\n\n\tfunction pause() external virtual override onlyOwner whenNotPaused {\n\t\t_pause();\n\t}\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyOwner {\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit Recovered(_msgSender(), token, to, amount);\n\t}\n\n\tfunction setFeeLogic(address account) external virtual override onlyOwner {\n\t\trequire(account != address(0), \"ETHtx: feeLogic zero address\");\n\t\t_feeLogic = account;\n\t\temit FeeLogicSet(_msgSender(), account);\n\t}\n\n\tfunction setMinter(address account) external virtual override onlyOwner {\n\t\t_minter = account;\n\t\temit MinterSet(_msgSender(), account);\n\t}\n\n\tfunction unpause() external virtual override onlyOwner whenPaused {\n\t\t_unpause();\n\t}\n\n\t/* External Views */\n\n\tfunction minter() public view virtual override returns (address) {\n\t\treturn _minter;\n\t}\n\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn \"Ethereum Transaction\";\n\t}\n\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn \"ETHtx\";\n\t}\n}\n"
    },
    "contracts/tokens/mocks/ETHtx/ETHtxData_v1_0_0.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\n/* solhint-disable-next-line contract-name-camelcase */\nabstract contract ETHtxData_v1_0_0 {\n\taddress internal _minter;\n\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/mocks/ETHtx/IETHtx_v1_0_0.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\n/* solhint-disable-next-line contract-name-camelcase */\ninterface IETHtx_v1_0_0 {\n\t/* Views */\n\n\tfunction minter() external view returns (address);\n\n\t/* Mutators */\n\n\tfunction burn(address account, uint256 amount) external;\n\n\tfunction mint(address account, uint256 amount) external;\n\n\tfunction pause() external;\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction setFeeLogic(address account) external;\n\n\tfunction setMinter(address account) external;\n\n\tfunction unpause() external;\n\n\t/* Events */\n\n\tevent FeeLogicSet(address indexed author, address indexed account);\n\tevent MinterSet(address indexed author, address indexed account);\n\tevent Recovered(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n}\n"
    },
    "contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/v3.4.0-solc-0.7/contracts/access/OwnableUpgradeable.sol\n *\n * Changes:\n * - Added owner argument to initializer\n * - Reformatted styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* solhint-disable func-name-mixedcase */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tfunction __Ownable_init(address owner_) internal initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t}\n\n\tfunction __Ownable_init_unchained(address owner_) internal initializer {\n\t\t_owner = owner_;\n\t\temit OwnershipTransferred(address(0), owner_);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/ETHmx/ETHmx.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nimport \"./ETHmxData.sol\";\nimport \"../ERC20/ERC20Upgradeable.sol\";\nimport \"../interfaces/IETHmx.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\n\ncontract ETHmx is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tPausableUpgradeable,\n\tERC20Upgradeable,\n\tETHmxData,\n\tIETHmx\n{\n\tusing SafeERC20 for IERC20;\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializer */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t\t__Pausable_init_unchained();\n\t\t__ERC20_init_unchained();\n\t}\n\n\t/* Modifiers */\n\n\tmodifier onlyMinter {\n\t\trequire(_msgSender() == minter(), \"ETHmx: caller is not the minter\");\n\t\t_;\n\t}\n\n\t/* External Mutators */\n\n\tfunction burn(uint256 amount) external virtual override {\n\t\t_burn(_msgSender(), amount);\n\t}\n\n\tfunction mintTo(address account, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyMinter\n\t\twhenNotPaused\n\t{\n\t\t_mint(account, amount);\n\t}\n\n\tfunction pause() external virtual override onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyOwner {\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit Recovered(_msgSender(), token, to, amount);\n\t}\n\n\tfunction setMinter(address account) public virtual override onlyOwner {\n\t\t_minter = account;\n\t\temit MinterSet(_msgSender(), account);\n\t}\n\n\tfunction unpause() external virtual override onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/* Public Views */\n\n\tfunction minter() public view virtual override returns (address) {\n\t\treturn _minter;\n\t}\n\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn \"ETHtx Minter Token\";\n\t}\n\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn \"ETHmx\";\n\t}\n}\n"
    },
    "contracts/tokens/ETHmx/ETHmxData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ETHmxData {\n\taddress internal _minter;\n\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/tokens/interfaces/IETHmx.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IETHmx {\n\t/* Views */\n\n\tfunction minter() external view returns (address);\n\n\t/* Mutators */\n\n\tfunction burn(uint256 amount) external;\n\n\tfunction mintTo(address account, uint256 amount) external;\n\n\tfunction pause() external;\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction setMinter(address account) external;\n\n\tfunction unpause() external;\n\n\t/* Events */\n\n\tevent MinterSet(address indexed author, address indexed account);\n\tevent Recovered(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n}\n"
    },
    "contracts/tokens/mocks/MockETHmx.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../ETHmx/ETHmx.sol\";\n\ncontract MockETHmx is ETHmx {\n\tconstructor(address owner_) ETHmx(owner_) {\n\t\treturn;\n\t}\n\n\tfunction mockMint(address account, uint256 amount) external {\n\t\t_mint(account, amount);\n\t}\n}\n"
    },
    "contracts/rewards/ETHmxRewards/ETHmxRewards.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ETHmxRewardsData.sol\";\nimport \"../../tokens/interfaces/IETHmx.sol\";\nimport \"../interfaces/IETHmxRewards.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\n\n// High accuracy in block.timestamp is not needed.\n// https://consensys.github.io/smart-contract-best-practices/recommendations/#the-15-second-rule\n/* solhint-disable not-rely-on-time */\n\ncontract ETHmxRewards is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tPausableUpgradeable,\n\tETHmxRewardsData,\n\tIETHmxRewards\n{\n\tusing Address for address payable;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\tstruct ETHmxRewardsArgs {\n\t\taddress ethmx;\n\t\taddress weth;\n\t\tuint256 accrualUpdateInterval;\n\t}\n\n\t/* Immutable Internal State */\n\n\tuint256 internal constant _MULTIPLIER = 1e36;\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializer */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t\t__Pausable_init_unchained();\n\n\t\t_arptSnapshots.push(0);\n\t}\n\n\tfunction postInit(ETHmxRewardsArgs memory _args) external virtual onlyOwner {\n\t\taddress sender = _msgSender();\n\n\t\t_ethmx = _args.ethmx;\n\t\temit ETHmxSet(sender, _args.ethmx);\n\n\t\t_weth = _args.weth;\n\t\temit WETHSet(sender, _args.weth);\n\n\t\t_accrualUpdateInterval = _args.accrualUpdateInterval;\n\t\temit AccrualUpdateIntervalSet(sender, _args.accrualUpdateInterval);\n\t}\n\n\t/* Fallbacks */\n\n\treceive() external payable {\n\t\t// Only accept ETH via fallback from the WETH contract\n\t\trequire(msg.sender == weth());\n\t}\n\n\t/* Public Views */\n\n\tfunction accrualUpdateInterval()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _accrualUpdateInterval;\n\t}\n\n\tfunction accruedRewardsPerToken()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _arptSnapshots[_arptSnapshots.length - 1];\n\t}\n\n\tfunction accruedRewardsPerTokenLast(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _arptSnapshots[_arptLastIdx[account]];\n\t}\n\n\tfunction ethmx() public view virtual override returns (address) {\n\t\treturn _ethmx;\n\t}\n\n\tfunction lastAccrualUpdate()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _lastAccrualUpdate;\n\t}\n\n\tfunction lastRewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _rewardsFor[account];\n\t}\n\n\tfunction lastStakedBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _stakedFor[account];\n\t}\n\n\tfunction lastTotalRewardsAccrued()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _lastTotalRewardsAccrued;\n\t}\n\n\tfunction readyForUpdate() external view virtual override returns (bool) {\n\t\tif (_lastAccrualUpdate > block.timestamp) {\n\t\t\treturn false;\n\t\t}\n\t\tuint256 timePassed = block.timestamp - _lastAccrualUpdate;\n\t\treturn timePassed >= _accrualUpdateInterval;\n\t}\n\n\tfunction rewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Gas savings\n\t\tuint256 rewards = _rewardsFor[account];\n\t\tuint256 staked = _stakedFor[account];\n\n\t\tif (staked == 0) {\n\t\t\treturn rewards;\n\t\t}\n\n\t\tuint256[] memory arptValues = _arptSnapshots;\n\t\tuint256 length = arptValues.length;\n\t\tuint256 arpt = arptValues[length - 1];\n\t\tuint256 lastIdx = _arptLastIdx[account];\n\t\tuint256 arptDelta = arpt - arptValues[lastIdx];\n\n\t\tif (arptDelta == 0) {\n\t\t\treturn rewards;\n\t\t}\n\n\t\t// Calculate reward and new stake\n\t\tuint256 currentRewards = 0;\n\t\tfor (uint256 i = lastIdx + 1; i < length; i++) {\n\t\t\tarptDelta = arptValues[i] - arptValues[i - 1];\n\t\t\tif (arptDelta >= _MULTIPLIER) {\n\t\t\t\t// This should handle any plausible overflow\n\t\t\t\trewards += staked;\n\t\t\t\tstaked = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentRewards = staked.mul(arptDelta) / _MULTIPLIER;\n\t\t\trewards += currentRewards;\n\t\t\tstaked -= currentRewards;\n\t\t}\n\n\t\treturn rewards;\n\t}\n\n\tfunction stakedBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Gas savings\n\t\tuint256 staked = _stakedFor[account];\n\t\tif (staked == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256[] memory arptValues = _arptSnapshots;\n\t\tuint256 length = arptValues.length;\n\t\tuint256 arpt = arptValues[length - 1];\n\t\tuint256 lastIdx = _arptLastIdx[account];\n\t\tuint256 arptDelta = arpt - arptValues[lastIdx];\n\n\t\tif (arptDelta == 0) {\n\t\t\treturn staked;\n\t\t}\n\n\t\t// Calculate reward and new stake\n\t\tuint256 currentRewards = 0;\n\t\tfor (uint256 i = lastIdx + 1; i < length; i++) {\n\t\t\tarptDelta = arptValues[i] - arptValues[i - 1];\n\t\t\tif (arptDelta >= _MULTIPLIER) {\n\t\t\t\t// This should handle any plausible overflow\n\t\t\t\tstaked = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentRewards = staked.mul(arptDelta) / _MULTIPLIER;\n\t\t\tstaked -= currentRewards;\n\t\t}\n\n\t\treturn staked;\n\t}\n\n\tfunction totalRewardsAccrued()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Overflow is OK\n\t\treturn _currentRewardsBalance() + _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemed()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _totalRewardsRedeemed;\n\t}\n\n\tfunction totalStaked() public view virtual override returns (uint256) {\n\t\treturn _totalStaked;\n\t}\n\n\tfunction unredeemableRewards()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _rewardsFor[address(0)];\n\t}\n\n\tfunction weth() public view virtual override returns (address) {\n\t\treturn _weth;\n\t}\n\n\t/* Public Mutators */\n\n\tfunction exit(bool asWETH) public virtual override {\n\t\taddress account = _msgSender();\n\t\tunstakeAll();\n\t\t_redeemReward(account, _rewardsFor[account], asWETH);\n\t}\n\n\tfunction pause() public virtual override onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction recoverUnredeemableRewards(address to, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(\n\t\t\tamount <= _rewardsFor[address(0)],\n\t\t\t\"ETHmxRewards: recovery amount greater than unredeemable\"\n\t\t);\n\t\t_rewardsFor[address(0)] -= amount;\n\t\tIERC20(weth()).safeTransfer(to, amount);\n\t\temit RecoveredUnredeemableRewards(_msgSender(), to, amount);\n\t}\n\n\tfunction recoverUnstaked(address to, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\tIERC20 ethmxHandle = IERC20(ethmx());\n\t\tuint256 unstaked = ethmxHandle.balanceOf(address(this)).sub(_totalStaked);\n\n\t\trequire(\n\t\t\tamount <= unstaked,\n\t\t\t\"ETHmxRewards: recovery amount greater than unstaked\"\n\t\t);\n\n\t\tethmxHandle.safeTransfer(to, amount);\n\t\temit RecoveredUnstaked(_msgSender(), to, amount);\n\t}\n\n\tfunction recoverUnsupportedERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) public virtual override onlyOwner {\n\t\trequire(token != ethmx(), \"ETHmxRewards: cannot recover ETHmx\");\n\t\trequire(token != weth(), \"ETHmxRewards: cannot recover WETH\");\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit RecoveredUnsupported(_msgSender(), token, to, amount);\n\t}\n\n\tfunction redeemAllRewards(bool asWETH) public virtual override {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\t_redeemReward(account, _rewardsFor[account], asWETH);\n\t}\n\n\tfunction redeemReward(uint256 amount, bool asWETH) public virtual override {\n\t\trequire(amount != 0, \"ETHmxRewards: cannot redeem zero\");\n\t\taddress account = _msgSender();\n\t\t// Update reward first (since it only goes up)\n\t\t_updateRewardFor(account);\n\t\trequire(\n\t\t\tamount <= _rewardsFor[account],\n\t\t\t\"ETHmxRewards: cannot redeem more rewards than earned\"\n\t\t);\n\t\t_redeemReward(account, amount, asWETH);\n\t}\n\n\tfunction setAccrualUpdateInterval(uint256 interval)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_accrualUpdateInterval = interval;\n\t\temit AccrualUpdateIntervalSet(_msgSender(), interval);\n\t}\n\n\tfunction setEthmx(address account) public virtual override onlyOwner {\n\t\t_ethmx = account;\n\t\temit ETHmxSet(_msgSender(), account);\n\t}\n\n\tfunction setWeth(address account) public virtual override onlyOwner {\n\t\t_weth = account;\n\t\temit WETHSet(_msgSender(), account);\n\t}\n\n\tfunction stake(uint256 amount) public virtual override whenNotPaused {\n\t\trequire(amount != 0, \"ETHmxRewards: cannot stake zero\");\n\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\n\t\t_stakedFor[account] = _stakedFor[account].add(amount);\n\t\t_totalStaked = _totalStaked.add(amount);\n\n\t\tIERC20(ethmx()).safeTransferFrom(account, address(this), amount);\n\t\temit Staked(account, amount);\n\t}\n\n\tfunction unpause() public virtual override onlyOwner {\n\t\t_unpause();\n\t}\n\n\tfunction unstake(uint256 amount) public virtual override {\n\t\trequire(amount != 0, \"ETHmxRewards: cannot unstake zero\");\n\t\taddress account = _msgSender();\n\n\t\t// Check against initial stake (since it only goes down)\n\t\trequire(\n\t\t\tamount <= _stakedFor[account],\n\t\t\t\"ETHmxRewards: cannot unstake more than staked balance\"\n\t\t);\n\n\t\t// Update stake\n\t\t_updateRewardFor(account);\n\t\t// Cap amount with updated stake\n\t\tuint256 staked = _stakedFor[account];\n\t\tif (amount > staked) {\n\t\t\tamount = staked;\n\t\t}\n\n\t\t_unstake(account, amount);\n\t}\n\n\tfunction unstakeAll() public virtual override {\n\t\taddress account = _msgSender();\n\t\t// Update stake first\n\t\t_updateRewardFor(account);\n\t\t_unstake(account, _stakedFor[account]);\n\t}\n\n\tfunction updateAccrual() public virtual override {\n\t\tuint256 timePassed =\n\t\t\tblock.timestamp.sub(\n\t\t\t\t_lastAccrualUpdate,\n\t\t\t\t\"ETHmxRewards: block is older than last accrual update\"\n\t\t\t);\n\t\trequire(\n\t\t\ttimePassed >= _accrualUpdateInterval,\n\t\t\t\"ETHmxRewards: too soon to update accrual\"\n\t\t);\n\n\t\t_updateAccrual();\n\t}\n\n\tfunction updateReward() public virtual override {\n\t\t_updateRewardFor(_msgSender());\n\t}\n\n\t/* Internal Views */\n\n\tfunction _currentRewardsBalance() internal view virtual returns (uint256) {\n\t\treturn IERC20(weth()).balanceOf(address(this));\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _burnETHmx(uint256 amount) internal virtual {\n\t\t_totalStaked = _totalStaked.sub(amount);\n\t\tIETHmx(ethmx()).burn(amount);\n\t}\n\n\tfunction _redeemReward(\n\t\taddress account,\n\t\tuint256 amount,\n\t\tbool asWETH\n\t) internal virtual {\n\t\t// Should be guaranteed safe by caller (gas savings)\n\t\t_rewardsFor[account] -= amount;\n\t\t// Overflow is OK\n\t\t_totalRewardsRedeemed += amount;\n\n\t\tif (asWETH) {\n\t\t\tIERC20(weth()).safeTransfer(account, amount);\n\t\t} else {\n\t\t\tIWETH(weth()).withdraw(amount);\n\t\t\tpayable(account).sendValue(amount);\n\t\t}\n\n\t\temit RewardPaid(account, amount);\n\t}\n\n\tfunction _unstake(address account, uint256 amount) internal virtual {\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Should be guaranteed safe by caller\n\t\t_stakedFor[account] -= amount;\n\t\t_totalStaked = _totalStaked.sub(amount);\n\n\t\tIERC20(ethmx()).safeTransfer(account, amount);\n\t\temit Unstaked(account, amount);\n\t}\n\n\tfunction _updateAccrual() internal virtual {\n\t\tuint256 rewardsAccrued = totalRewardsAccrued();\n\t\t// Overflow is OK\n\t\tuint256 newRewards = rewardsAccrued - _lastTotalRewardsAccrued;\n\n\t\tif (newRewards == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Gas savings\n\t\tuint256 tstaked = _totalStaked;\n\n\t\tif (newRewards < tstaked) {\n\t\t\t// Add breathing room for better rounding, overflow is OK\n\t\t\tuint256 arpt = accruedRewardsPerToken();\n\t\t\tarpt += newRewards.mul(_MULTIPLIER) / tstaked;\n\t\t\t_arptSnapshots.push(arpt);\n\t\t\t_burnETHmx(newRewards);\n\t\t} else {\n\t\t\tuint256 leftover = newRewards - tstaked;\n\t\t\t// Assign excess to zero address\n\t\t\t_rewardsFor[address(0)] = _rewardsFor[address(0)].add(leftover);\n\n\t\t\tif (tstaked != 0) {\n\t\t\t\tuint256 arpt = accruedRewardsPerToken();\n\t\t\t\t// newRewards when tokens == totalStaked\n\t\t\t\tarpt += _MULTIPLIER;\n\t\t\t\t_arptSnapshots.push(arpt);\n\t\t\t\t_burnETHmx(tstaked);\n\t\t\t}\n\t\t}\n\n\t\t_lastTotalRewardsAccrued = rewardsAccrued;\n\t\t_lastAccrualUpdate = block.timestamp;\n\t\temit AccrualUpdated(_msgSender(), rewardsAccrued);\n\t}\n\n\tfunction _updateRewardFor(address account) internal virtual {\n\t\t// Gas savings\n\t\tuint256[] memory arptValues = _arptSnapshots;\n\t\tuint256 length = arptValues.length;\n\t\tuint256 arpt = arptValues[length - 1];\n\t\tuint256 lastIdx = _arptLastIdx[account];\n\t\tuint256 arptDelta = arpt - arptValues[lastIdx];\n\t\tuint256 staked = _stakedFor[account];\n\n\t\t_arptLastIdx[account] = length - 1;\n\n\t\tif (staked == 0 || arptDelta == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Calculate reward and new stake\n\t\tuint256 currentRewards = 0;\n\t\tuint256 newRewards = 0;\n\t\tfor (uint256 i = lastIdx + 1; i < length; i++) {\n\t\t\tarptDelta = arptValues[i] - arptValues[i - 1];\n\t\t\tif (arptDelta >= _MULTIPLIER) {\n\t\t\t\t// This should handle any plausible overflow\n\t\t\t\tnewRewards += staked;\n\t\t\t\tstaked = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrentRewards = staked.mul(arptDelta) / _MULTIPLIER;\n\t\t\tnewRewards += currentRewards;\n\t\t\tstaked -= currentRewards;\n\t\t}\n\n\t\t// Update state\n\t\t_stakedFor[account] = staked;\n\t\t_rewardsFor[account] = _rewardsFor[account].add(newRewards);\n\t}\n}\n"
    },
    "contracts/rewards/ETHmxRewards/ETHmxRewardsData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ETHmxRewardsData {\n\taddress internal _ethmx;\n\taddress internal _weth;\n\n\tuint256[] internal _arptSnapshots;\n\tmapping(address => uint256) internal _arptLastIdx;\n\n\tuint256 internal _lastAccrualUpdate;\n\tuint256 internal _accrualUpdateInterval;\n\n\tmapping(address => uint256) internal _rewardsFor;\n\tuint256 internal _lastTotalRewardsAccrued;\n\tuint256 internal _totalRewardsRedeemed;\n\n\tmapping(address => uint256) internal _stakedFor;\n\tuint256 internal _totalStaked;\n\n\tuint256[39] private __gap;\n}\n"
    },
    "contracts/rewards/interfaces/IETHmxRewards.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IETHmxRewards {\n\t/* Views */\n\n\tfunction accrualUpdateInterval() external view returns (uint256);\n\n\tfunction accruedRewardsPerToken() external view returns (uint256);\n\n\tfunction accruedRewardsPerTokenLast(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction ethmx() external view returns (address);\n\n\tfunction lastAccrualUpdate() external view returns (uint256);\n\n\tfunction lastRewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction lastStakedBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction lastTotalRewardsAccrued() external view returns (uint256);\n\n\tfunction readyForUpdate() external view returns (bool);\n\n\tfunction rewardsBalanceOf(address account) external view returns (uint256);\n\n\tfunction stakedBalanceOf(address account) external view returns (uint256);\n\n\tfunction totalRewardsAccrued() external view returns (uint256);\n\n\tfunction totalRewardsRedeemed() external view returns (uint256);\n\n\tfunction totalStaked() external view returns (uint256);\n\n\tfunction unredeemableRewards() external view returns (uint256);\n\n\tfunction weth() external view returns (address);\n\n\t/* Mutators */\n\n\tfunction exit(bool asWETH) external;\n\n\tfunction pause() external;\n\n\tfunction recoverUnredeemableRewards(address to, uint256 amount) external;\n\n\tfunction recoverUnstaked(address to, uint256 amount) external;\n\n\tfunction recoverUnsupportedERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction redeemAllRewards(bool asWETH) external;\n\n\tfunction redeemReward(uint256 amount, bool asWETH) external;\n\n\tfunction setAccrualUpdateInterval(uint256 interval) external;\n\n\tfunction setEthmx(address account) external;\n\n\tfunction setWeth(address account) external;\n\n\tfunction stake(uint256 amount) external;\n\n\tfunction unpause() external;\n\n\tfunction unstake(uint256 amount) external;\n\n\tfunction unstakeAll() external;\n\n\tfunction updateAccrual() external;\n\n\tfunction updateReward() external;\n\n\t/* Events */\n\n\tevent AccrualUpdated(address indexed author, uint256 accruedRewards);\n\tevent AccrualUpdateIntervalSet(address indexed author, uint256 interval);\n\tevent ETHmxSet(address indexed author, address indexed account);\n\tevent RecoveredUnredeemableRewards(\n\t\taddress indexed author,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RecoveredUnstaked(\n\t\taddress indexed author,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RecoveredUnsupported(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RewardPaid(address indexed to, uint256 amount);\n\tevent Staked(address indexed account, uint256 amount);\n\tevent Unstaked(address indexed account, uint256 amount);\n\tevent WETHSet(address indexed author, address indexed account);\n}\n"
    },
    "contracts/tokens/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\ninterface IWETH {\n\tfunction deposit() external payable;\n\n\tfunction withdraw(uint256) external;\n}\n"
    },
    "contracts/rewards/mocks/MockETHmxRewards.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../ETHmxRewards/ETHmxRewards.sol\";\n\ncontract MockETHmxRewards is ETHmxRewards {\n\tconstructor(address owner_) ETHmxRewards(owner_) {\n\t\treturn;\n\t}\n\n\tfunction mockUpdateAccrual() external {\n\t\t_updateAccrual();\n\t}\n\n\tfunction setAccruedRewardsPerToken(uint256 value) external {\n\t\t_arptSnapshots.push(value);\n\t}\n\n\tfunction setLastTotalRewardsAccrued(uint256 value) external {\n\t\t_lastTotalRewardsAccrued = value;\n\t}\n\n\tfunction setTotalRewardsRedeemed(uint256 value) external {\n\t\t_totalRewardsRedeemed = value;\n\t}\n\n\tfunction setLastAccrualUpdate(uint256 value) external {\n\t\t_lastAccrualUpdate = value;\n\t}\n}\n"
    },
    "contracts/rewards/LPRewards/LPRewards.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./LPRewardsData.sol\";\nimport \"../../libraries/EnumerableMap.sol\";\nimport \"../interfaces/ILPRewards.sol\";\nimport \"../interfaces/IValuePerToken.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\n\ncontract LPRewards is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tPausableUpgradeable,\n\tLPRewardsData,\n\tILPRewards\n{\n\tusing Address for address payable;\n\tusing EnumerableMap for EnumerableMap.AddressToUintMap;\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\t/* Immutable Internal State */\n\n\tuint256 internal constant _MULTIPLIER = 1e36;\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializers */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t\t__Pausable_init_unchained();\n\t}\n\n\t/* Fallbacks */\n\n\treceive() external payable {\n\t\t// Only accept ETH via fallback from the WETH contract\n\t\trequire(msg.sender == _rewardsToken);\n\t}\n\n\t/* Modifiers */\n\n\tmodifier supportsToken(address token) {\n\t\trequire(supportsStakingToken(token), \"LPRewards: unsupported token\");\n\t\t_;\n\t}\n\n\t/* Public Views */\n\n\tfunction accruedRewardsPerTokenFor(address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].arpt;\n\t}\n\n\tfunction accruedRewardsPerTokenLastFor(address account, address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _users[account].rewardsFor[token].arptLast;\n\t}\n\n\tfunction lastRewardsBalanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 total)\n\t{\n\t\tUserData storage user = _users[account];\n\t\tEnumerableSet.AddressSet storage tokens = user.tokensWithRewards;\n\t\tfor (uint256 i = 0; i < tokens.length(); i++) {\n\t\t\ttotal += user.rewardsFor[tokens.at(i)].pending;\n\t\t}\n\t}\n\n\tfunction lastRewardsBalanceOfFor(address account, address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _users[account].rewardsFor[token].pending;\n\t}\n\n\tfunction lastTotalRewardsAccrued()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _lastTotalRewardsAccrued;\n\t}\n\n\tfunction lastTotalRewardsAccruedFor(address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].lastRewardsAccrued;\n\t}\n\n\tfunction numStakingTokens()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokens.length();\n\t}\n\n\tfunction rewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn lastRewardsBalanceOf(account) + _allPendingRewardsFor(account);\n\t}\n\n\tfunction rewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tuint256 rewards = lastRewardsBalanceOfFor(account, token);\n\t\tuint256 amountStaked = stakedBalanceOf(account, token);\n\t\tif (amountStaked != 0) {\n\t\t\trewards += _pendingRewardsFor(account, token, amountStaked);\n\t\t}\n\t\treturn rewards;\n\t}\n\n\tfunction rewardsForToken(address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].rewards;\n\t}\n\n\tfunction rewardsToken() public view virtual override returns (address) {\n\t\treturn _rewardsToken;\n\t}\n\n\tfunction sharesFor(address account, address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _shares(token, stakedBalanceOf(account, token));\n\t}\n\n\tfunction sharesPerToken(address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _shares(token, 1e18);\n\t}\n\n\tfunction stakedBalanceOf(address account, address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tEnumerableMap.AddressToUintMap storage staked = _users[account].staked;\n\t\tif (staked.contains(token)) {\n\t\t\treturn staked.get(token);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction stakingTokenAt(uint256 index)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _tokens.at(index);\n\t}\n\n\tfunction supportsStakingToken(address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _tokens.contains(token);\n\t}\n\n\tfunction totalRewardsAccrued()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Overflow is OK\n\t\treturn _currentRewardsBalance() + _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsAccruedFor(address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tTokenData storage td = _tokenData[token];\n\t\t// Overflow is OK\n\t\treturn td.rewards + td.rewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemed()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemedFor(address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].rewardsRedeemed;\n\t}\n\n\tfunction totalShares()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 total)\n\t{\n\t\tfor (uint256 i = 0; i < _tokens.length(); i++) {\n\t\t\ttotal = total.add(_totalSharesForToken(_tokens.at(i)));\n\t\t}\n\t}\n\n\tfunction totalSharesFor(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 total)\n\t{\n\t\tEnumerableMap.AddressToUintMap storage staked = _users[account].staked;\n\t\tfor (uint256 i = 0; i < staked.length(); i++) {\n\t\t\t(address token, uint256 amount) = staked.at(i);\n\t\t\ttotal = total.add(_shares(token, amount));\n\t\t}\n\t}\n\n\tfunction totalSharesForToken(address token)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _totalSharesForToken(token);\n\t}\n\n\tfunction totalStaked(address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].totalStaked;\n\t}\n\n\tfunction unredeemableRewards()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _unredeemableRewards;\n\t}\n\n\tfunction valuePerTokenImpl(address token)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _tokenData[token].valueImpl;\n\t}\n\n\t/* Public Mutators */\n\n\tfunction addToken(address token, address tokenValueImpl)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(!supportsStakingToken(token), \"LPRewards: token already added\");\n\t\trequire(\n\t\t\ttokenValueImpl != address(0),\n\t\t\t\"LPRewards: tokenValueImpl cannot be zero address\"\n\t\t);\n\t\t_tokens.add(token);\n\t\t// Only update implementation in case this was previously used and removed\n\t\t_tokenData[token].valueImpl = tokenValueImpl;\n\t\temit TokenAdded(_msgSender(), token, tokenValueImpl);\n\t}\n\n\tfunction changeTokenValueImpl(address token, address tokenValueImpl)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t\tsupportsToken(token)\n\t{\n\t\trequire(\n\t\t\ttokenValueImpl != address(0),\n\t\t\t\"LPRewards: tokenValueImpl cannot be zero address\"\n\t\t);\n\t\t_tokenData[token].valueImpl = tokenValueImpl;\n\t\temit TokenValueImplChanged(_msgSender(), token, tokenValueImpl);\n\t}\n\n\tfunction exit(bool asWETH) external virtual override {\n\t\tunstakeAll();\n\t\tredeemAllRewards(asWETH);\n\t}\n\n\tfunction exitFrom(address token, bool asWETH) external virtual override {\n\t\tunstakeAllFrom(token);\n\t\tredeemAllRewardsFrom(token, asWETH);\n\t}\n\n\tfunction pause() external virtual override onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction recoverUnredeemableRewards(address to, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(\n\t\t\tamount <= _unredeemableRewards,\n\t\t\t\"LPRewards: recovery amount > unredeemable\"\n\t\t);\n\t\t_unredeemableRewards -= amount;\n\t\tIERC20(_rewardsToken).safeTransfer(to, amount);\n\t\temit RecoveredUnredeemableRewards(_msgSender(), to, amount);\n\t}\n\n\tfunction recoverUnstaked(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyOwner {\n\t\trequire(token != _rewardsToken, \"LPRewards: cannot recover rewardsToken\");\n\n\t\tuint256 unstaked =\n\t\t\tIERC20(token).balanceOf(address(this)).sub(totalStaked(token));\n\n\t\trequire(amount <= unstaked, \"LPRewards: recovery amount > unstaked\");\n\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit RecoveredUnstaked(_msgSender(), token, to, amount);\n\t}\n\n\tfunction redeemAllRewards(bool asWETH) public virtual override {\n\t\taddress account = _msgSender();\n\t\t_updateAllRewardsFor(account);\n\n\t\tUserData storage user = _users[account];\n\t\tEnumerableSet.AddressSet storage tokens = user.tokensWithRewards;\n\t\tuint256 redemption = 0;\n\n\t\tfor (uint256 length = tokens.length(); length > 0; length--) {\n\t\t\taddress token = tokens.at(0);\n\t\t\tTokenData storage td = _tokenData[token];\n\t\t\tUserTokenRewards storage rewards = user.rewardsFor[token];\n\t\t\tuint256 pending = rewards.pending; // Save gas\n\n\t\t\tredemption += pending;\n\n\t\t\trewards.pending = 0;\n\n\t\t\ttd.rewards = td.rewards.sub(pending);\n\t\t\ttd.rewardsRedeemed += pending;\n\n\t\t\temit RewardPaid(account, token, pending);\n\t\t\ttokens.remove(token);\n\t\t}\n\n\t\t_totalRewardsRedeemed += redemption;\n\n\t\t_sendRewards(account, redemption, asWETH);\n\t}\n\n\tfunction redeemAllRewardsFrom(address token, bool asWETH)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t{\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account, token);\n\t\tuint256 pending = _users[account].rewardsFor[token].pending;\n\t\tif (pending != 0) {\n\t\t\t_redeemRewardFrom(token, pending, asWETH);\n\t\t}\n\t}\n\n\tfunction redeemReward(uint256 amount, bool asWETH)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(amount != 0, \"LPRewards: cannot redeem zero\");\n\t\taddress account = _msgSender();\n\t\t_updateAllRewardsFor(account);\n\t\trequire(\n\t\t\tamount <= lastRewardsBalanceOf(account),\n\t\t\t\"LPRewards: cannot redeem more rewards than earned\"\n\t\t);\n\n\t\tUserData storage user = _users[account];\n\t\tEnumerableSet.AddressSet storage tokens = user.tokensWithRewards;\n\t\tuint256 amountLeft = amount;\n\n\t\tfor (uint256 length = tokens.length(); length > 0; length--) {\n\t\t\taddress token = tokens.at(0);\n\t\t\tTokenData storage td = _tokenData[token];\n\t\t\tUserTokenRewards storage rewards = user.rewardsFor[token];\n\n\t\t\tuint256 pending = rewards.pending; // Save gas\n\t\t\tuint256 taken = 0;\n\t\t\tif (pending <= amountLeft) {\n\t\t\t\ttaken = pending;\n\t\t\t\ttokens.remove(token);\n\t\t\t} else {\n\t\t\t\ttaken = amountLeft;\n\t\t\t}\n\n\t\t\trewards.pending = pending - taken;\n\n\t\t\ttd.rewards = td.rewards.sub(taken);\n\t\t\ttd.rewardsRedeemed += taken;\n\n\t\t\tamountLeft -= taken;\n\n\t\t\temit RewardPaid(account, token, taken);\n\n\t\t\tif (amountLeft == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t_totalRewardsRedeemed += amount;\n\n\t\t_sendRewards(account, amount, asWETH);\n\t}\n\n\tfunction redeemRewardFrom(\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbool asWETH\n\t) external virtual override {\n\t\trequire(amount != 0, \"LPRewards: cannot redeem zero\");\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account, token);\n\t\trequire(\n\t\t\tamount <= _users[account].rewardsFor[token].pending,\n\t\t\t\"LPRewards: cannot redeem more rewards than earned\"\n\t\t);\n\t\t_redeemRewardFrom(token, amount, asWETH);\n\t}\n\n\tfunction removeToken(address token)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t\tsupportsToken(token)\n\t{\n\t\t_tokens.remove(token);\n\t\t// Clean up. Keep totalStaked and rewards since those will be cleaned up by\n\t\t// users unstaking and redeeming.\n\t\t_tokenData[token].valueImpl = address(0);\n\t\temit TokenRemoved(_msgSender(), token);\n\t}\n\n\tfunction setRewardsToken(address token) public virtual override onlyOwner {\n\t\t_rewardsToken = token;\n\t\temit RewardsTokenSet(_msgSender(), token);\n\t}\n\n\tfunction stake(address token, uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\twhenNotPaused\n\t\tsupportsToken(token)\n\t{\n\t\trequire(amount != 0, \"LPRewards: cannot stake zero\");\n\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account, token);\n\n\t\tUserData storage user = _users[account];\n\t\tTokenData storage td = _tokenData[token];\n\t\ttd.totalStaked += amount;\n\t\tuser.staked.set(token, amount + stakedBalanceOf(account, token));\n\n\t\tIERC20(token).safeTransferFrom(account, address(this), amount);\n\t\temit Staked(account, token, amount);\n\t}\n\n\tfunction unpause() external virtual override onlyOwner {\n\t\t_unpause();\n\t}\n\n\tfunction unstake(address token, uint256 amount) external virtual override {\n\t\trequire(amount != 0, \"LPRewards: cannot unstake zero\");\n\n\t\taddress account = _msgSender();\n\t\t// Prevent making calls to any addresses that were never supported.\n\t\tuint256 staked = stakedBalanceOf(account, token);\n\t\trequire(\n\t\t\tamount <= staked,\n\t\t\t\"LPRewards: cannot unstake more than staked balance\"\n\t\t);\n\n\t\t_unstake(token, amount);\n\t}\n\n\tfunction unstakeAll() public virtual override {\n\t\tUserData storage user = _users[_msgSender()];\n\t\tfor (uint256 length = user.staked.length(); length > 0; length--) {\n\t\t\t(address token, uint256 amount) = user.staked.at(0);\n\t\t\t_unstake(token, amount);\n\t\t}\n\t}\n\n\tfunction unstakeAllFrom(address token) public virtual override {\n\t\t_unstake(token, stakedBalanceOf(_msgSender(), token));\n\t}\n\n\tfunction updateAccrual() external virtual override {\n\t\t// Gas savings\n\t\tuint256 totalRewardsAccrued_ = totalRewardsAccrued();\n\t\tuint256 pending = totalRewardsAccrued_ - _lastTotalRewardsAccrued;\n\t\tif (pending == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t_lastTotalRewardsAccrued = totalRewardsAccrued_;\n\n\t\t// Iterate once to know totalShares\n\t\tuint256 totalShares_ = 0;\n\t\t// Store some math for current shares to save on gas and revert ASAP.\n\t\tuint256[] memory pendingSharesFor = new uint256[](_tokens.length());\n\t\tfor (uint256 i = 0; i < _tokens.length(); i++) {\n\t\t\tuint256 share = _totalSharesForToken(_tokens.at(i));\n\t\t\tpendingSharesFor[i] = pending.mul(share);\n\t\t\ttotalShares_ = totalShares_.add(share);\n\t\t}\n\n\t\tif (totalShares_ == 0) {\n\t\t\t_unredeemableRewards = _unredeemableRewards.add(pending);\n\t\t\temit AccrualUpdated(_msgSender(), pending);\n\t\t\treturn;\n\t\t}\n\n\t\t// Iterate twice to allocate rewards to each token.\n\t\tfor (uint256 i = 0; i < _tokens.length(); i++) {\n\t\t\taddress token = _tokens.at(i);\n\t\t\tTokenData storage td = _tokenData[token];\n\t\t\ttd.rewards += pendingSharesFor[i] / totalShares_;\n\t\t\tuint256 rewardsAccrued = totalRewardsAccruedFor(token);\n\t\t\ttd.arpt = _accruedRewardsPerTokenFor(token, rewardsAccrued);\n\t\t\ttd.lastRewardsAccrued = rewardsAccrued;\n\t\t}\n\n\t\temit AccrualUpdated(_msgSender(), pending);\n\t}\n\n\tfunction updateReward() external virtual override {\n\t\t_updateAllRewardsFor(_msgSender());\n\t}\n\n\tfunction updateRewardFor(address token) external virtual override {\n\t\t_updateRewardFor(_msgSender(), token);\n\t}\n\n\t/* Internal Views */\n\n\tfunction _accruedRewardsPerTokenFor(address token, uint256 rewardsAccrued)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tTokenData storage td = _tokenData[token];\n\t\t// Gas savings\n\t\tuint256 totalStaked_ = td.totalStaked;\n\n\t\tif (totalStaked_ == 0) {\n\t\t\treturn td.arpt;\n\t\t}\n\n\t\t// Overflow is OK\n\t\tuint256 delta = rewardsAccrued - td.lastRewardsAccrued;\n\t\tif (delta == 0) {\n\t\t\treturn td.arpt;\n\t\t}\n\n\t\t// Use multiplier for better rounding\n\t\tuint256 rewardsPerToken = delta.mul(_MULTIPLIER) / totalStaked_;\n\n\t\t// Overflow is OK\n\t\treturn td.arpt + rewardsPerToken;\n\t}\n\n\tfunction _allPendingRewardsFor(address account)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256 total)\n\t{\n\t\tEnumerableMap.AddressToUintMap storage staked = _users[account].staked;\n\t\tfor (uint256 i = 0; i < staked.length(); i++) {\n\t\t\t(address token, uint256 amount) = staked.at(i);\n\t\t\ttotal += _pendingRewardsFor(account, token, amount);\n\t\t}\n\t}\n\n\tfunction _currentRewardsBalance() internal view virtual returns (uint256) {\n\t\treturn IERC20(_rewardsToken).balanceOf(address(this));\n\t}\n\n\tfunction _pendingRewardsFor(\n\t\taddress account,\n\t\taddress token,\n\t\tuint256 amountStaked\n\t) internal view virtual returns (uint256) {\n\t\tuint256 arpt = accruedRewardsPerTokenFor(token);\n\t\tuint256 arptLast = accruedRewardsPerTokenLastFor(account, token);\n\t\t// Overflow is OK\n\t\tuint256 arptDelta = arpt - arptLast;\n\n\t\treturn amountStaked.mul(arptDelta) / _MULTIPLIER;\n\t}\n\n\tfunction _shares(address token, uint256 amountStaked)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tif (!supportsStakingToken(token)) {\n\t\t\treturn 0;\n\t\t}\n\t\tIValuePerToken vptHandle = IValuePerToken(valuePerTokenImpl(token));\n\t\t(uint256 numerator, uint256 denominator) = vptHandle.valuePerToken();\n\t\tif (denominator == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t// Return a 1:1 ratio for value to shares\n\t\treturn amountStaked.mul(numerator) / denominator;\n\t}\n\n\tfunction _totalSharesForToken(address token)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\treturn _shares(token, _tokenData[token].totalStaked);\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _redeemRewardFrom(\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbool asWETH\n\t) internal virtual {\n\t\taddress account = _msgSender();\n\t\tUserData storage user = _users[account];\n\t\tUserTokenRewards storage rewards = user.rewardsFor[token];\n\t\tTokenData storage td = _tokenData[token];\n\t\tuint256 rewardLeft = rewards.pending - amount;\n\n\t\trewards.pending = rewardLeft;\n\t\tif (rewardLeft == 0) {\n\t\t\tuser.tokensWithRewards.remove(token);\n\t\t}\n\n\t\ttd.rewards = td.rewards.sub(amount);\n\t\ttd.rewardsRedeemed += amount;\n\n\t\t_totalRewardsRedeemed += amount;\n\n\t\t_sendRewards(account, amount, asWETH);\n\t\temit RewardPaid(account, token, amount);\n\t}\n\n\tfunction _sendRewards(\n\t\taddress to,\n\t\tuint256 amount,\n\t\tbool asWETH\n\t) internal virtual {\n\t\tif (asWETH) {\n\t\t\tIERC20(_rewardsToken).safeTransfer(to, amount);\n\t\t} else {\n\t\t\tIWETH(_rewardsToken).withdraw(amount);\n\t\t\tpayable(to).sendValue(amount);\n\t\t}\n\t}\n\n\tfunction _unstake(address token, uint256 amount) internal virtual {\n\t\taddress account = _msgSender();\n\n\t\t_updateRewardFor(account, token);\n\n\t\tTokenData storage td = _tokenData[token];\n\t\ttd.totalStaked = td.totalStaked.sub(amount);\n\n\t\tUserData storage user = _users[account];\n\t\tEnumerableMap.AddressToUintMap storage staked = user.staked;\n\n\t\tuint256 stakeLeft = staked.get(token).sub(amount);\n\t\tif (stakeLeft == 0) {\n\t\t\tstaked.remove(token);\n\t\t\tuser.rewardsFor[token].arptLast = 0;\n\t\t} else {\n\t\t\tstaked.set(token, stakeLeft);\n\t\t}\n\n\t\tIERC20(token).safeTransfer(account, amount);\n\t\temit Unstaked(account, token, amount);\n\t}\n\n\tfunction _updateRewardFor(address account, address token)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tUserData storage user = _users[account];\n\t\tUserTokenRewards storage rewards = user.rewardsFor[token];\n\t\tuint256 total = rewards.pending; // Save gas\n\t\tuint256 amountStaked = stakedBalanceOf(account, token);\n\t\tuint256 pending = _pendingRewardsFor(account, token, amountStaked);\n\t\tif (pending != 0) {\n\t\t\ttotal += pending;\n\t\t\trewards.pending = total;\n\t\t\tuser.tokensWithRewards.add(token);\n\t\t}\n\t\trewards.arptLast = accruedRewardsPerTokenFor(token);\n\t\treturn total;\n\t}\n\n\tfunction _updateAllRewardsFor(address account) internal virtual {\n\t\tEnumerableMap.AddressToUintMap storage staked = _users[account].staked;\n\t\tfor (uint256 i = 0; i < staked.length(); i++) {\n\t\t\t(address token, ) = staked.at(i);\n\t\t\t_updateRewardFor(account, token);\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/rewards/LPRewards/LPRewardsData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\nimport \"../../libraries/EnumerableMap.sol\";\n\nabstract contract LPRewardsData {\n\t/* Structs */\n\n\tstruct TokenData {\n\t\tuint256 arpt;\n\t\tuint256 lastRewardsAccrued;\n\t\tuint256 rewards;\n\t\tuint256 rewardsRedeemed;\n\t\tuint256 totalStaked;\n\t\taddress valueImpl;\n\t}\n\n\tstruct UserTokenRewards {\n\t\tuint256 pending;\n\t\tuint256 arptLast;\n\t}\n\n\tstruct UserData {\n\t\tEnumerableSet.AddressSet tokensWithRewards;\n\t\tmapping(address => UserTokenRewards) rewardsFor;\n\t\tEnumerableMap.AddressToUintMap staked;\n\t}\n\n\t/* State */\n\n\taddress internal _rewardsToken;\n\tuint256 internal _lastTotalRewardsAccrued;\n\tuint256 internal _totalRewardsRedeemed;\n\tuint256 internal _unredeemableRewards;\n\tEnumerableSet.AddressSet internal _tokens;\n\tmapping(address => TokenData) internal _tokenData;\n\tmapping(address => UserData) internal _users;\n\n\tuint256[43] private __gap;\n}\n"
    },
    "contracts/libraries/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0-solc-0.7/contracts/utils/EnumerableMap.sol\n *\n * Changes:\n * - Replaced UintToAddressMap with AddressToUintMap\n * - Reformatted styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\n * supported.\n */\nlibrary EnumerableMap {\n\t// To implement this library for multiple types with as little code\n\t// repetition as possible, we write it in terms of a generic Map type with\n\t// bytes32 keys and values.\n\t// The Map implementation uses private functions, and user-facing\n\t// implementations (such as Uint256ToAddressMap) are just wrappers around\n\t// the underlying Map.\n\t// This means that we can only create new EnumerableMaps for types that fit\n\t// in bytes32.\n\n\tstruct MapEntry {\n\t\tbytes32 _key;\n\t\tbytes32 _value;\n\t}\n\n\tstruct Map {\n\t\t// Storage of map keys and values\n\t\tMapEntry[] _entries;\n\t\t// Position of the entry defined by a key in the `entries` array, plus 1\n\t\t// because index 0 means a key is not in the map.\n\t\tmapping(bytes32 => uint256) _indexes;\n\t}\n\n\t/**\n\t * @dev Adds a key-value pair to a map, or updates the value for an existing\n\t * key. O(1).\n\t *\n\t * Returns true if the key was added to the map, that is if it was not\n\t * already present.\n\t */\n\tfunction _set(\n\t\tMap storage map,\n\t\tbytes32 key,\n\t\tbytes32 value\n\t) private returns (bool) {\n\t\t// We read and store the key's index to prevent multiple reads from the same storage slot\n\t\tuint256 keyIndex = map._indexes[key];\n\n\t\t// Equivalent to !contains(map, key)\n\t\tif (keyIndex == 0) {\n\t\t\tmap._entries.push(MapEntry({ _key: key, _value: value }));\n\t\t\t// The entry is stored at length-1, but we add 1 to all indexes\n\t\t\t// and use 0 as a sentinel value\n\t\t\tmap._indexes[key] = map._entries.length;\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmap._entries[keyIndex - 1]._value = value;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Removes a key-value pair from a map. O(1).\n\t *\n\t * Returns true if the key was removed from the map, that is if it was present.\n\t */\n\tfunction _remove(Map storage map, bytes32 key) private returns (bool) {\n\t\t// We read and store the key's index to prevent multiple reads from the same storage slot\n\t\tuint256 keyIndex = map._indexes[key];\n\n\t\t// Equivalent to contains(map, key)\n\t\tif (keyIndex != 0) {\n\t\t\t// To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\n\t\t\t// in the array, and then remove the last entry (sometimes called as 'swap and pop').\n\t\t\t// This modifies the order of the array, as noted in {at}.\n\n\t\t\tuint256 toDeleteIndex = keyIndex - 1;\n\t\t\tuint256 lastIndex = map._entries.length - 1;\n\n\t\t\t// When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\n\t\t\t// so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n\t\t\tMapEntry storage lastEntry = map._entries[lastIndex];\n\n\t\t\t// Move the last entry to the index where the entry to delete is\n\t\t\tmap._entries[toDeleteIndex] = lastEntry;\n\t\t\t// Update the index for the moved entry\n\t\t\tmap._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\n\n\t\t\t// Delete the slot where the moved entry was stored\n\t\t\tmap._entries.pop();\n\n\t\t\t// Delete the index for the deleted slot\n\t\t\tdelete map._indexes[key];\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns true if the key is in the map. O(1).\n\t */\n\tfunction _contains(Map storage map, bytes32 key)\n\t\tprivate\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn map._indexes[key] != 0;\n\t}\n\n\t/**\n\t * @dev Returns the number of key-value pairs in the map. O(1).\n\t */\n\tfunction _length(Map storage map) private view returns (uint256) {\n\t\treturn map._entries.length;\n\t}\n\n\t/**\n\t * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of entries inside the\n\t * array, and it may change when more entries are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction _at(Map storage map, uint256 index)\n\t\tprivate\n\t\tview\n\t\treturns (bytes32, bytes32)\n\t{\n\t\trequire(map._entries.length > index, \"EnumerableMap: index out of bounds\");\n\n\t\tMapEntry storage entry = map._entries[index];\n\t\treturn (entry._key, entry._value);\n\t}\n\n\t/**\n\t * @dev Returns the value associated with `key`.  O(1).\n\t *\n\t * Requirements:\n\t *\n\t * - `key` must be in the map.\n\t */\n\tfunction _get(Map storage map, bytes32 key) private view returns (bytes32) {\n\t\treturn _get(map, key, \"EnumerableMap: nonexistent key\");\n\t}\n\n\t/**\n\t * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n\t */\n\tfunction _get(\n\t\tMap storage map,\n\t\tbytes32 key,\n\t\tstring memory errorMessage\n\t) private view returns (bytes32) {\n\t\tuint256 keyIndex = map._indexes[key];\n\t\trequire(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\n\t\treturn map._entries[keyIndex - 1]._value; // All indexes are 1-based\n\t}\n\n\t// AddressToUintMap\n\n\tstruct AddressToUintMap {\n\t\tMap _inner;\n\t}\n\n\t/**\n\t * @dev Adds a key-value pair to a map, or updates the value for an existing\n\t * key. O(1).\n\t *\n\t * Returns true if the key was added to the map, that is if it was not\n\t * already present.\n\t */\n\tfunction set(\n\t\tAddressToUintMap storage map,\n\t\taddress key,\n\t\tuint256 value\n\t) internal returns (bool) {\n\t\treturn _set(map._inner, bytes32(uint256(key)), bytes32(value));\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the key was removed from the map, that is if it was present.\n\t */\n\tfunction remove(AddressToUintMap storage map, address key)\n\t\tinternal\n\t\treturns (bool)\n\t{\n\t\treturn _remove(map._inner, bytes32(uint256(key)));\n\t}\n\n\t/**\n\t * @dev Returns true if the key is in the map. O(1).\n\t */\n\tfunction contains(AddressToUintMap storage map, address key)\n\t\tinternal\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn _contains(map._inner, bytes32(uint256(key)));\n\t}\n\n\t/**\n\t * @dev Returns the number of elements in the map. O(1).\n\t */\n\tfunction length(AddressToUintMap storage map)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn _length(map._inner);\n\t}\n\n\t/**\n\t * @dev Returns the element stored at position `index` in the set. O(1).\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(AddressToUintMap storage map, uint256 index)\n\t\tinternal\n\t\tview\n\t\treturns (address, uint256)\n\t{\n\t\t(bytes32 key, bytes32 value) = _at(map._inner, index);\n\t\treturn (address(uint256(key)), uint256(value));\n\t}\n\n\t/**\n\t * @dev Returns the value associated with `key`.  O(1).\n\t *\n\t * Requirements:\n\t *\n\t * - `key` must be in the map.\n\t */\n\tfunction get(AddressToUintMap storage map, address key)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn uint256(_get(map._inner, bytes32(uint256(key))));\n\t}\n\n\t/**\n\t * @dev Same as {get}, with a custom error message when `key` is not in the map.\n\t */\n\tfunction get(\n\t\tAddressToUintMap storage map,\n\t\taddress key,\n\t\tstring memory errorMessage\n\t) internal view returns (uint256) {\n\t\treturn uint256(_get(map._inner, bytes32(uint256(key)), errorMessage));\n\t}\n}\n"
    },
    "contracts/rewards/interfaces/ILPRewards.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface ILPRewards {\n\t/* Views */\n\n\tfunction accruedRewardsPerTokenFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction accruedRewardsPerTokenLastFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction lastRewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction lastRewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction lastTotalRewardsAccrued() external view returns (uint256);\n\n\tfunction lastTotalRewardsAccruedFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction numStakingTokens() external view returns (uint256);\n\n\tfunction rewardsBalanceOf(address account) external view returns (uint256);\n\n\tfunction rewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction rewardsForToken(address token) external view returns (uint256);\n\n\tfunction rewardsToken() external view returns (address);\n\n\tfunction sharesFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction sharesPerToken(address token) external view returns (uint256);\n\n\tfunction stakedBalanceOf(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction stakingTokenAt(uint256 index) external view returns (address);\n\n\tfunction supportsStakingToken(address token) external view returns (bool);\n\n\tfunction totalRewardsAccrued() external view returns (uint256);\n\n\tfunction totalRewardsAccruedFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction totalRewardsRedeemed() external view returns (uint256);\n\n\tfunction totalRewardsRedeemedFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction totalShares() external view returns (uint256);\n\n\tfunction totalSharesFor(address account) external view returns (uint256);\n\n\tfunction totalSharesForToken(address token) external view returns (uint256);\n\n\tfunction totalStaked(address token) external view returns (uint256);\n\n\tfunction unredeemableRewards() external view returns (uint256);\n\n\tfunction valuePerTokenImpl(address token) external view returns (address);\n\n\t/* Mutators */\n\n\tfunction addToken(address token, address tokenValueImpl) external;\n\n\tfunction changeTokenValueImpl(address token, address tokenValueImpl)\n\t\texternal;\n\n\tfunction exit(bool asWETH) external;\n\n\tfunction exitFrom(address token, bool asWETH) external;\n\n\tfunction pause() external;\n\n\tfunction recoverUnredeemableRewards(address to, uint256 amount) external;\n\n\tfunction recoverUnstaked(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction redeemAllRewards(bool asWETH) external;\n\n\tfunction redeemAllRewardsFrom(address token, bool asWETH) external;\n\n\tfunction redeemReward(uint256 amount, bool asWETH) external;\n\n\tfunction redeemRewardFrom(\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbool asWETH\n\t) external;\n\n\tfunction removeToken(address token) external;\n\n\tfunction setRewardsToken(address token) external;\n\n\tfunction stake(address token, uint256 amount) external;\n\n\tfunction unpause() external;\n\n\tfunction unstake(address token, uint256 amount) external;\n\n\tfunction unstakeAll() external;\n\n\tfunction unstakeAllFrom(address token) external;\n\n\tfunction updateAccrual() external;\n\n\tfunction updateReward() external;\n\n\tfunction updateRewardFor(address token) external;\n\n\t/* Events */\n\n\tevent AccrualUpdated(address indexed author, uint256 accruedRewards);\n\tevent RecoveredUnredeemableRewards(\n\t\taddress indexed author,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RecoveredUnstaked(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RewardPaid(\n\t\taddress indexed account,\n\t\taddress indexed token,\n\t\tuint256 amount\n\t);\n\tevent RewardsTokenSet(address indexed author, address indexed token);\n\tevent Staked(address indexed account, address indexed token, uint256 amount);\n\tevent TokenAdded(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed tokenValueImpl\n\t);\n\tevent TokenRemoved(address indexed author, address indexed token);\n\tevent TokenValueImplChanged(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed tokenValueImpl\n\t);\n\tevent Unstaked(\n\t\taddress indexed account,\n\t\taddress indexed token,\n\t\tuint256 amount\n\t);\n}\n"
    },
    "contracts/rewards/interfaces/IValuePerToken.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IValuePerToken {\n\t/* Views */\n\n\tfunction token() external view returns (address);\n\n\tfunction valuePerToken()\n\t\texternal\n\t\tview\n\t\treturns (uint256 numerator, uint256 denominator);\n}\n"
    },
    "contracts/rewards/mocks/MockLPRewards.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../LPRewards/LPRewards.sol\";\n\ncontract MockLPRewards is LPRewards {\n\tconstructor(address owner_) LPRewards(owner_) {\n\t\treturn;\n\t}\n\n\tfunction multiplier() external pure returns (uint256) {\n\t\treturn _MULTIPLIER;\n\t}\n\n\tfunction setAccruedRewardsPerTokenFor(address token, uint256 value)\n\t\texternal\n\t{\n\t\t_tokenData[token].arpt = value;\n\t}\n\n\tfunction setRewardsRedeemedFor(address token, uint256 value) external {\n\t\t_tokenData[token].rewardsRedeemed = value;\n\t}\n\n\tfunction setLastRewardsAccruedFor(address token, uint256 value) external {\n\t\t_tokenData[token].lastRewardsAccrued = value;\n\t}\n\n\tfunction setLastTotalRewardsAccrued(uint256 value) external {\n\t\t_lastTotalRewardsAccrued = value;\n\t}\n\n\tfunction setTotalRewardsRedeemed(uint256 value) external {\n\t\t_totalRewardsRedeemed = value;\n\t}\n}\n"
    },
    "contracts/rewards/ValuePerUNIV2.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IValuePerToken.sol\";\nimport \"../libraries/Sqrt.sol\";\n\ninterface IUniswapV2Factory {\n\tfunction feeTo() external view returns (address);\n}\n\ninterface IUniswapV2Pair {\n\tfunction factory() external view returns (address);\n\n\tfunction getReserves()\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint112 reserve0,\n\t\t\tuint112 reserve1,\n\t\t\tuint32 blockTimestampLast\n\t\t);\n\n\tfunction kLast() external view returns (uint256);\n\n\tfunction token0() external view returns (address);\n\n\tfunction token1() external view returns (address);\n\n\tfunction totalSupply() external view returns (uint256);\n}\n\ncontract ValuePerUNIV2 is IValuePerToken {\n\tusing SafeMath for uint256;\n\n\t/* Immutable Public State */\n\n\taddress public immutable override token;\n\taddress public immutable valueToken;\n\n\t/* Constructor */\n\n\tconstructor(address _token, address _valueToken) {\n\t\tIUniswapV2Pair tokenHandle = IUniswapV2Pair(_token);\n\t\taddress token0 = tokenHandle.token0();\n\t\taddress token1 = tokenHandle.token1();\n\n\t\trequire(\n\t\t\t_valueToken == token0 || _valueToken == token1,\n\t\t\t\"ValuePerUNIV2: pool lacks token\"\n\t\t);\n\n\t\ttoken = _token;\n\t\tvalueToken = _valueToken;\n\t}\n\n\t/* External Views */\n\n\tfunction valuePerToken()\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 numerator, uint256 denominator)\n\t{\n\t\tIUniswapV2Pair tokenHandle = IUniswapV2Pair(token);\n\t\tuint256 totalSupply = tokenHandle.totalSupply();\n\t\t(uint112 reserve0, uint112 reserve1, ) = tokenHandle.getReserves();\n\n\t\t// Adjust totalSupply when feeOn\n\t\t// Minted fee liquidity is equivalent to 1/6th of the growth in sqrt(k)\n\t\tif (feeOn()) {\n\t\t\tuint256 kLast = tokenHandle.kLast();\n\t\t\tif (kLast > 0) {\n\t\t\t\tuint256 rootK = Sqrt.sqrt(uint256(reserve0).mul(reserve1));\n\t\t\t\tuint256 rootKLast = Sqrt.sqrt(kLast);\n\t\t\t\tif (rootK > rootKLast) {\n\t\t\t\t\tuint256 n = totalSupply.mul(rootK - rootKLast);\n\t\t\t\t\tuint256 d = rootK.mul(5).add(rootKLast);\n\t\t\t\t\tuint256 feeLiquidity = n / d;\n\t\t\t\t\ttotalSupply = totalSupply.add(feeLiquidity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\taddress token0 = tokenHandle.token0();\n\n\t\t// Use correct reserve\n\t\tnumerator = valueToken == token0 ? reserve0 : reserve1;\n\t\tdenominator = totalSupply;\n\t}\n\n\t/* Public Views */\n\n\tfunction feeOn() public view returns (bool) {\n\t\taddress factory = IUniswapV2Pair(token).factory();\n\t\taddress feeTo = IUniswapV2Factory(factory).feeTo();\n\t\treturn feeTo != address(0);\n\t}\n}\n"
    },
    "contracts/libraries/Sqrt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/**\n * Babylonian square root, courtesy of dapp-bin, RJ Catalona (https://github.com/VoR0220), and Uniswap.\n * dapp-bin PR: https://github.com/ethereum/dapp-bin/pull/50/files\n * RJ Catalona's branch of dapp-bin: https://github.com/VoR0220/dapp-bin/blob/VoR0220-patch-1/library/math.sol\n * Uniswap: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\n */\n\nlibrary Sqrt {\n\t// babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n\tfunction sqrt(uint256 y) internal pure returns (uint256 z) {\n\t\tif (y > 3) {\n\t\t\tz = y;\n\t\t\tuint256 x = y / 2 + 1;\n\t\t\twhile (x < z) {\n\t\t\t\tz = x;\n\t\t\t\tx = (y / x + x) / 2;\n\t\t\t}\n\t\t} else if (y != 0) {\n\t\t\tz = 1;\n\t\t}\n\t}\n}\n"
    },
    "contracts/rewards/mooniswap/Mooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * From https://github.com/1inch-exchange/mooniswap/blob/v1.0/contracts/Mooniswap.sol\n * This is used exclusively for testing.\n * Changes:\n * - Updated from solidity ^0.6.0 to ^0.7.0.\n * - Reformatted styling in line with this repository.\n */\n\n/* solhint-disable not-rely-on-time */\n\n/*\nMIT License\n\nCopyright (c) 2020 Mooniswap\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"./UniERC20.sol\";\nimport \"../../libraries/Sqrt.sol\";\n\ninterface IFactory {\n\tfunction fee() external view returns (uint256);\n}\n\nlibrary VirtualBalance {\n\tusing SafeMath for uint256;\n\n\tstruct Data {\n\t\tuint216 balance;\n\t\tuint40 time;\n\t}\n\n\tuint256 public constant DECAY_PERIOD = 5 minutes;\n\n\tfunction set(VirtualBalance.Data storage self, uint256 balance) internal {\n\t\tself.balance = uint216(balance);\n\t\tself.time = uint40(block.timestamp);\n\t}\n\n\tfunction update(VirtualBalance.Data storage self, uint256 realBalance)\n\t\tinternal\n\t{\n\t\tset(self, current(self, realBalance));\n\t}\n\n\tfunction scale(\n\t\tVirtualBalance.Data storage self,\n\t\tuint256 realBalance,\n\t\tuint256 num,\n\t\tuint256 denom\n\t) internal {\n\t\tset(\n\t\t\tself,\n\t\t\tcurrent(self, realBalance).mul(num).add(denom.sub(1)).div(denom)\n\t\t);\n\t}\n\n\tfunction current(VirtualBalance.Data memory self, uint256 realBalance)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tuint256 timePassed =\n\t\t\tMath.min(DECAY_PERIOD, block.timestamp.sub(self.time));\n\t\tuint256 timeRemain = DECAY_PERIOD.sub(timePassed);\n\t\treturn\n\t\t\tuint256(self.balance)\n\t\t\t\t.mul(timeRemain)\n\t\t\t\t.add(realBalance.mul(timePassed))\n\t\t\t\t.div(DECAY_PERIOD);\n\t}\n}\n\ncontract Mooniswap is ERC20, ReentrancyGuard, Ownable {\n\tusing Sqrt for uint256;\n\tusing SafeMath for uint256;\n\tusing UniERC20 for IERC20;\n\tusing VirtualBalance for VirtualBalance.Data;\n\n\tstruct Balances {\n\t\tuint256 src;\n\t\tuint256 dst;\n\t}\n\n\tstruct SwapVolumes {\n\t\tuint128 confirmed;\n\t\tuint128 result;\n\t}\n\n\tevent Deposited(address indexed account, uint256 amount);\n\n\tevent Withdrawn(address indexed account, uint256 amount);\n\n\tevent Swapped(\n\t\taddress indexed account,\n\t\taddress indexed src,\n\t\taddress indexed dst,\n\t\tuint256 amount,\n\t\tuint256 result,\n\t\tuint256 srcBalance,\n\t\tuint256 dstBalance,\n\t\tuint256 totalSupply,\n\t\taddress referral\n\t);\n\n\tuint256 public constant REFERRAL_SHARE = 20; // 1/share = 5% of LPs revenue\n\tuint256 public constant BASE_SUPPLY = 1000; // Total supply on first deposit\n\tuint256 public constant FEE_DENOMINATOR = 1e18;\n\n\tIFactory public factory;\n\tIERC20[] public tokens;\n\tmapping(IERC20 => bool) public isToken;\n\tmapping(IERC20 => SwapVolumes) public volumes;\n\tmapping(IERC20 => VirtualBalance.Data) public virtualBalancesForAddition;\n\tmapping(IERC20 => VirtualBalance.Data) public virtualBalancesForRemoval;\n\n\tconstructor(\n\t\tIERC20[] memory assets,\n\t\tstring memory name,\n\t\tstring memory symbol\n\t) ERC20(name, symbol) {\n\t\trequire(bytes(name).length > 0, \"Mooniswap: name is empty\");\n\t\trequire(bytes(symbol).length > 0, \"Mooniswap: symbol is empty\");\n\t\trequire(assets.length == 2, \"Mooniswap: only 2 tokens allowed\");\n\n\t\tfactory = IFactory(msg.sender);\n\t\ttokens = assets;\n\t\tfor (uint256 i = 0; i < assets.length; i++) {\n\t\t\trequire(!isToken[assets[i]], \"Mooniswap: duplicate tokens\");\n\t\t\tisToken[assets[i]] = true;\n\t\t}\n\t}\n\n\tfunction fee() public view returns (uint256) {\n\t\treturn factory.fee();\n\t}\n\n\tfunction getTokens() external view returns (IERC20[] memory) {\n\t\treturn tokens;\n\t}\n\n\tfunction decayPeriod() external pure returns (uint256) {\n\t\treturn VirtualBalance.DECAY_PERIOD;\n\t}\n\n\tfunction getBalanceForAddition(IERC20 token) public view returns (uint256) {\n\t\tuint256 balance = token.uniBalanceOf(address(this));\n\t\treturn\n\t\t\tMath.max(virtualBalancesForAddition[token].current(balance), balance);\n\t}\n\n\tfunction getBalanceForRemoval(IERC20 token) public view returns (uint256) {\n\t\tuint256 balance = token.uniBalanceOf(address(this));\n\t\treturn\n\t\t\tMath.min(virtualBalancesForRemoval[token].current(balance), balance);\n\t}\n\n\tfunction getReturn(\n\t\tIERC20 src,\n\t\tIERC20 dst,\n\t\tuint256 amount\n\t) external view returns (uint256) {\n\t\treturn\n\t\t\t_getReturn(\n\t\t\t\tsrc,\n\t\t\t\tdst,\n\t\t\t\tamount,\n\t\t\t\tgetBalanceForAddition(src),\n\t\t\t\tgetBalanceForRemoval(dst)\n\t\t\t);\n\t}\n\n\tfunction deposit(uint256[] calldata amounts, uint256[] calldata minAmounts)\n\t\texternal\n\t\tpayable\n\t\tnonReentrant\n\t\treturns (uint256 fairSupply)\n\t{\n\t\tIERC20[] memory _tokens = tokens;\n\t\trequire(\n\t\t\tamounts.length == _tokens.length,\n\t\t\t\"Mooniswap: wrong amounts length\"\n\t\t);\n\t\trequire(\n\t\t\tmsg.value ==\n\t\t\t\t(\n\t\t\t\t\t_tokens[0].isETH()\n\t\t\t\t\t\t? amounts[0]\n\t\t\t\t\t\t: (_tokens[1].isETH() ? amounts[1] : 0)\n\t\t\t\t),\n\t\t\t\"Mooniswap: wrong value usage\"\n\t\t);\n\n\t\tuint256[] memory realBalances = new uint256[](amounts.length);\n\t\tfor (uint256 i = 0; i < realBalances.length; i++) {\n\t\t\trealBalances[i] = _tokens[i].uniBalanceOf(address(this)).sub(\n\t\t\t\t_tokens[i].isETH() ? msg.value : 0\n\t\t\t);\n\t\t}\n\n\t\tuint256 totalSupply = totalSupply();\n\t\tif (totalSupply == 0) {\n\t\t\tfairSupply = BASE_SUPPLY.mul(99);\n\t\t\t_mint(address(this), BASE_SUPPLY); // Donate up to 1%\n\n\t\t\t// Use the greatest token amount but not less than 99k for the initial supply\n\t\t\tfor (uint256 i = 0; i < amounts.length; i++) {\n\t\t\t\tfairSupply = Math.max(fairSupply, amounts[i]);\n\t\t\t}\n\t\t} else {\n\t\t\t// Pre-compute fair supply\n\t\t\tfairSupply = type(uint256).max;\n\t\t\tfor (uint256 i = 0; i < amounts.length; i++) {\n\t\t\t\tfairSupply = Math.min(\n\t\t\t\t\tfairSupply,\n\t\t\t\t\ttotalSupply.mul(amounts[i]).div(realBalances[i])\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tuint256 fairSupplyCached = fairSupply;\n\t\tfor (uint256 i = 0; i < amounts.length; i++) {\n\t\t\trequire(amounts[i] > 0, \"Mooniswap: amount is zero\");\n\t\t\tuint256 amount =\n\t\t\t\t(totalSupply == 0)\n\t\t\t\t\t? amounts[i]\n\t\t\t\t\t: realBalances[i].mul(fairSupplyCached).add(totalSupply - 1).div(\n\t\t\t\t\t\ttotalSupply\n\t\t\t\t\t);\n\t\t\trequire(amount >= minAmounts[i], \"Mooniswap: minAmount not reached\");\n\n\t\t\t_tokens[i].uniTransferFromSenderToThis(amount);\n\t\t\tif (totalSupply > 0) {\n\t\t\t\tuint256 confirmed =\n\t\t\t\t\t_tokens[i].uniBalanceOf(address(this)).sub(realBalances[i]);\n\t\t\t\tfairSupply = Math.min(\n\t\t\t\t\tfairSupply,\n\t\t\t\t\ttotalSupply.mul(confirmed).div(realBalances[i])\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tif (totalSupply > 0) {\n\t\t\tfor (uint256 i = 0; i < amounts.length; i++) {\n\t\t\t\tvirtualBalancesForRemoval[_tokens[i]].scale(\n\t\t\t\t\trealBalances[i],\n\t\t\t\t\ttotalSupply.add(fairSupply),\n\t\t\t\t\ttotalSupply\n\t\t\t\t);\n\t\t\t\tvirtualBalancesForAddition[_tokens[i]].scale(\n\t\t\t\t\trealBalances[i],\n\t\t\t\t\ttotalSupply.add(fairSupply),\n\t\t\t\t\ttotalSupply\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\trequire(fairSupply > 0, \"Mooniswap: result is not enough\");\n\t\t_mint(msg.sender, fairSupply);\n\n\t\temit Deposited(msg.sender, fairSupply);\n\t}\n\n\tfunction withdraw(uint256 amount, uint256[] memory minReturns)\n\t\texternal\n\t\tnonReentrant\n\t{\n\t\tuint256 totalSupply = totalSupply();\n\t\t_burn(msg.sender, amount);\n\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\tIERC20 token = tokens[i];\n\n\t\t\tuint256 preBalance = token.uniBalanceOf(address(this));\n\t\t\tuint256 value = preBalance.mul(amount).div(totalSupply);\n\t\t\ttoken.uniTransfer(msg.sender, value);\n\t\t\trequire(\n\t\t\t\ti >= minReturns.length || value >= minReturns[i],\n\t\t\t\t\"Mooniswap: result is not enough\"\n\t\t\t);\n\n\t\t\tvirtualBalancesForAddition[token].scale(\n\t\t\t\tpreBalance,\n\t\t\t\ttotalSupply.sub(amount),\n\t\t\t\ttotalSupply\n\t\t\t);\n\t\t\tvirtualBalancesForRemoval[token].scale(\n\t\t\t\tpreBalance,\n\t\t\t\ttotalSupply.sub(amount),\n\t\t\t\ttotalSupply\n\t\t\t);\n\t\t}\n\n\t\temit Withdrawn(msg.sender, amount);\n\t}\n\n\tfunction swap(\n\t\tIERC20 src,\n\t\tIERC20 dst,\n\t\tuint256 amount,\n\t\tuint256 minReturn,\n\t\taddress referral\n\t) external payable nonReentrant returns (uint256 result) {\n\t\trequire(\n\t\t\tmsg.value == (src.isETH() ? amount : 0),\n\t\t\t\"Mooniswap: wrong value usage\"\n\t\t);\n\n\t\tBalances memory balances =\n\t\t\tBalances({\n\t\t\t\tsrc: src.uniBalanceOf(address(this)).sub(src.isETH() ? msg.value : 0),\n\t\t\t\tdst: dst.uniBalanceOf(address(this))\n\t\t\t});\n\n\t\t// catch possible airdrops and external balance changes for deflationary tokens\n\t\tuint256 srcAdditionBalance =\n\t\t\tMath.max(\n\t\t\t\tvirtualBalancesForAddition[src].current(balances.src),\n\t\t\t\tbalances.src\n\t\t\t);\n\t\tuint256 dstRemovalBalance =\n\t\t\tMath.min(\n\t\t\t\tvirtualBalancesForRemoval[dst].current(balances.dst),\n\t\t\t\tbalances.dst\n\t\t\t);\n\n\t\tsrc.uniTransferFromSenderToThis(amount);\n\t\tuint256 confirmed = src.uniBalanceOf(address(this)).sub(balances.src);\n\t\tresult = _getReturn(\n\t\t\tsrc,\n\t\t\tdst,\n\t\t\tconfirmed,\n\t\t\tsrcAdditionBalance,\n\t\t\tdstRemovalBalance\n\t\t);\n\t\trequire(\n\t\t\tresult > 0 && result >= minReturn,\n\t\t\t\"Mooniswap: return is not enough\"\n\t\t);\n\t\tdst.uniTransfer(msg.sender, result);\n\n\t\t// Update virtual balances to the same direction only at imbalanced state\n\t\tif (srcAdditionBalance != balances.src) {\n\t\t\tvirtualBalancesForAddition[src].set(srcAdditionBalance.add(confirmed));\n\t\t}\n\t\tif (dstRemovalBalance != balances.dst) {\n\t\t\tvirtualBalancesForRemoval[dst].set(dstRemovalBalance.sub(result));\n\t\t}\n\n\t\t// Update virtual balances to the opposite direction\n\t\tvirtualBalancesForRemoval[src].update(balances.src);\n\t\tvirtualBalancesForAddition[dst].update(balances.dst);\n\n\t\tif (referral != address(0)) {\n\t\t\tuint256 invariantRatio = uint256(1e36);\n\t\t\tinvariantRatio = invariantRatio.mul(balances.src.add(confirmed)).div(\n\t\t\t\tbalances.src\n\t\t\t);\n\t\t\tinvariantRatio = invariantRatio.mul(balances.dst.sub(result)).div(\n\t\t\t\tbalances.dst\n\t\t\t);\n\t\t\tif (invariantRatio > 1e36) {\n\t\t\t\t// calculate share only if invariant increased\n\t\t\t\tuint256 referralShare =\n\t\t\t\t\tinvariantRatio.sqrt().sub(1e18).mul(totalSupply()).div(1e18).div(\n\t\t\t\t\t\tREFERRAL_SHARE\n\t\t\t\t\t);\n\t\t\t\tif (referralShare > 0) {\n\t\t\t\t\t_mint(referral, referralShare);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\temit Swapped(\n\t\t\tmsg.sender,\n\t\t\taddress(src),\n\t\t\taddress(dst),\n\t\t\tconfirmed,\n\t\t\tresult,\n\t\t\tbalances.src,\n\t\t\tbalances.dst,\n\t\t\ttotalSupply(),\n\t\t\treferral\n\t\t);\n\n\t\t// Overflow of uint128 is desired\n\t\tvolumes[src].confirmed += uint128(confirmed);\n\t\tvolumes[src].result += uint128(result);\n\t}\n\n\tfunction rescueFunds(IERC20 token, uint256 amount)\n\t\texternal\n\t\tnonReentrant\n\t\tonlyOwner\n\t{\n\t\tuint256[] memory balances = new uint256[](tokens.length);\n\t\tfor (uint256 i = 0; i < balances.length; i++) {\n\t\t\tbalances[i] = tokens[i].uniBalanceOf(address(this));\n\t\t}\n\n\t\ttoken.uniTransfer(msg.sender, amount);\n\n\t\tfor (uint256 i = 0; i < balances.length; i++) {\n\t\t\trequire(\n\t\t\t\ttokens[i].uniBalanceOf(address(this)) >= balances[i],\n\t\t\t\t\"Mooniswap: access denied\"\n\t\t\t);\n\t\t}\n\t\trequire(\n\t\t\tbalanceOf(address(this)) >= BASE_SUPPLY,\n\t\t\t\"Mooniswap: access denied\"\n\t\t);\n\t}\n\n\tfunction _getReturn(\n\t\tIERC20 src,\n\t\tIERC20 dst,\n\t\tuint256 amount,\n\t\tuint256 srcBalance,\n\t\tuint256 dstBalance\n\t) internal view returns (uint256) {\n\t\tif (isToken[src] && isToken[dst] && src != dst && amount > 0) {\n\t\t\tuint256 taxedAmount = amount.sub(amount.mul(fee()).div(FEE_DENOMINATOR));\n\t\t\treturn taxedAmount.mul(dstBalance).div(srcBalance.add(taxedAmount));\n\t\t}\n\t\treturn 0;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/rewards/mooniswap/UniERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * From https://github.com/1inch-exchange/mooniswap/blob/v1.0/contracts/libraries/UniERC20.sol\n * This is used exclusively for testing.\n * Changes:\n * - Updated from solidity ^0.6.0 to ^0.7.0.\n * - Reformatted styling in line with this repository.\n */\n\n/*\nMIT License\n\nCopyright (c) 2020 Mooniswap\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n\nlibrary UniERC20 {\n\tusing SafeMath for uint256;\n\tusing SafeERC20 for IERC20;\n\n\tfunction isETH(IERC20 token) internal pure returns (bool) {\n\t\treturn (address(token) == address(0));\n\t}\n\n\tfunction uniBalanceOf(IERC20 token, address account)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tif (isETH(token)) {\n\t\t\treturn account.balance;\n\t\t} else {\n\t\t\treturn token.balanceOf(account);\n\t\t}\n\t}\n\n\tfunction uniTransfer(\n\t\tIERC20 token,\n\t\taddress payable to,\n\t\tuint256 amount\n\t) internal {\n\t\tif (amount > 0) {\n\t\t\tif (isETH(token)) {\n\t\t\t\tto.transfer(amount);\n\t\t\t} else {\n\t\t\t\ttoken.safeTransfer(to, amount);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction uniTransferFromSenderToThis(IERC20 token, uint256 amount) internal {\n\t\tif (amount > 0) {\n\t\t\tif (isETH(token)) {\n\t\t\t\trequire(msg.value >= amount, \"UniERC20: not enough value\");\n\t\t\t\tif (msg.value > amount) {\n\t\t\t\t\t// Return remainder if exist\n\t\t\t\t\tmsg.sender.transfer(msg.value.sub(amount));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoken.safeTransferFrom(msg.sender, address(this), amount);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction uniSymbol(IERC20 token) internal view returns (string memory) {\n\t\tif (isETH(token)) {\n\t\t\treturn \"ETH\";\n\t\t}\n\n\t\t(bool success, bytes memory data) =\n\t\t\taddress(token).staticcall{ gas: 20000 }(\n\t\t\t\tabi.encodeWithSignature(\"symbol()\")\n\t\t\t);\n\t\tif (!success) {\n\t\t\t(success, data) = address(token).staticcall{ gas: 20000 }(\n\t\t\t\tabi.encodeWithSignature(\"SYMBOL()\")\n\t\t\t);\n\t\t}\n\n\t\tif (success && data.length >= 96) {\n\t\t\t(uint256 offset, uint256 len) = abi.decode(data, (uint256, uint256));\n\t\t\tif (offset == 0x20 && len > 0 && len <= 256) {\n\t\t\t\treturn string(abi.decode(data, (bytes)));\n\t\t\t}\n\t\t}\n\n\t\tif (success && data.length == 32) {\n\t\t\tuint256 len = 0;\n\t\t\twhile (len < data.length && data[len] >= 0x20 && data[len] <= 0x7E) {\n\t\t\t\tlen++;\n\t\t\t}\n\n\t\t\tif (len > 0) {\n\t\t\t\tbytes memory result = new bytes(len);\n\t\t\t\tfor (uint256 i = 0; i < len; i++) {\n\t\t\t\t\tresult[i] = data[i];\n\t\t\t\t}\n\t\t\t\treturn string(result);\n\t\t\t}\n\t\t}\n\n\t\treturn _toHex(address(token));\n\t}\n\n\tfunction _toHex(address account) private pure returns (string memory) {\n\t\treturn _toHex(abi.encodePacked(account));\n\t}\n\n\tfunction _toHex(bytes memory data) private pure returns (string memory) {\n\t\tbytes memory str = new bytes(2 + data.length * 2);\n\t\tstr[0] = \"0\";\n\t\tstr[1] = \"x\";\n\t\tuint256 j = 2;\n\t\tfor (uint256 i = 0; i < data.length; i++) {\n\t\t\tuint256 a = uint8(data[i]) >> 4;\n\t\t\tuint256 b = uint8(data[i]) & 0x0f;\n\t\t\tstr[j++] = bytes1(uint8(a + 48 + (a / 10) * 39));\n\t\t\tstr[j++] = bytes1(uint8(b + 48 + (b / 10) * 39));\n\t\t}\n\n\t\treturn string(str);\n\t}\n}\n"
    },
    "contracts/rewards/RewardsManager/RewardsManagerAuto.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../interfaces/IRewardsManagerAuto.sol\";\n\ncontract RewardsManagerAuto is ReentrancyGuard, Ownable, IRewardsManagerAuto {\n\tusing SafeCast for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\tusing SafeMath for uint128;\n\n\t/* Types */\n\n\tstruct Shares {\n\t\tuint128 active;\n\t\tuint128 total;\n\t}\n\n\t/* Immutable Public State */\n\n\tIERC20 public immutable override rewardsToken;\n\n\t/* Mutable Internal State */\n\n\tuint256 internal _accruedRewardsPerShare;\n\tmapping(address => uint256) internal _accruedRewardsPerSharePaid;\n\taddress internal _defaultRecipient;\n\tuint256 internal _lastTotalRewardsAccrued;\n\tmapping(address => uint256) internal _rewards;\n\tuint256 internal _totalRewardsRedeemed;\n\tmapping(address => Shares) internal _shares;\n\tuint128 internal _totalActiveShares;\n\tuint128 internal _totalShares;\n\n\t/* Constructor */\n\n\tconstructor(IERC20 _rewardsToken) Ownable() {\n\t\trewardsToken = _rewardsToken;\n\t}\n\n\t/* External Mutators */\n\n\tfunction activateShares() external override {\n\t\t_activate(_msgSender());\n\t}\n\n\tfunction activateSharesFor(address account) external override onlyOwner {\n\t\t_activate(account);\n\t}\n\n\tfunction addShares(address account, uint128 amount)\n\t\texternal\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsManagerAuto: cannot add shares to the zero address\"\n\t\t);\n\t\t_addShares(account, amount);\n\t}\n\n\tfunction deactivateShares() external override {\n\t\t_deactivate(_msgSender());\n\t}\n\n\tfunction deactivateSharesFor(address account) external override onlyOwner {\n\t\t_deactivate(account);\n\t}\n\n\tfunction recoverUnsupportedERC20(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external override onlyOwner {\n\t\t_recoverUnsupportedERC20(token, to, amount);\n\t}\n\n\tfunction removeShares(address account, uint128 amount)\n\t\texternal\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_removeShares(account, amount);\n\t}\n\n\tfunction setShares(\n\t\taddress account,\n\t\tuint128 value,\n\t\tbool isActive\n\t) external override onlyOwner {\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsManagerAuto: cannot set shares for zero address\"\n\t\t);\n\t\t_setShares(account, value, isActive);\n\t}\n\n\tfunction setDefaultRecipient(address account) external override onlyOwner {\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsManagerAuto: cannot set zero address as the default recipient\"\n\t\t);\n\t\trequire(\n\t\t\taccount != address(this),\n\t\t\t\"RewardsManagerAuto: cannot use this contract as the default recipient\"\n\t\t);\n\t\t_setDefaultRecipient(account);\n\t}\n\n\t/* Public Views */\n\n\tfunction accruedRewardsPerShare() public view override returns (uint256) {\n\t\treturn _getAccruedRewardsPerShare(totalRewardsAccrued());\n\t}\n\n\tfunction accruedRewardsPerSharePaid(address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _accruedRewardsPerSharePaid[account];\n\t}\n\n\tfunction defaultRecipient() public view override returns (address) {\n\t\treturn _defaultRecipient;\n\t}\n\n\tfunction rewardsBalanceOf(address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _rewardsBalanceOfImpl(account, accruedRewardsPerShare());\n\t}\n\n\tfunction sharesFor(address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint128 active, uint128 total)\n\t{\n\t\tShares storage s = _shares[account];\n\t\treturn (s.active, s.total);\n\t}\n\n\tfunction totalRewardsAccrued() public view override returns (uint256) {\n\t\t// Overflow is OK\n\t\treturn rewardsToken.balanceOf(address(this)) + _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemed() public view override returns (uint256) {\n\t\treturn _totalRewardsRedeemed;\n\t}\n\n\tfunction totalShares() public view override returns (uint128) {\n\t\treturn _totalShares;\n\t}\n\n\t/* Public Mutators */\n\n\tfunction redeemAllRewards() public override nonReentrant {\n\t\t_redeemAllRewards();\n\t}\n\n\tfunction redeemReward(uint256 amount) public override nonReentrant {\n\t\t_redeemRewardTo(_msgSender(), amount);\n\t}\n\n\tfunction redeemRewardTo(address to, uint256 amount)\n\t\tpublic\n\t\toverride\n\t\tnonReentrant\n\t{\n\t\t_redeemRewardTo(to, amount);\n\t}\n\n\tfunction updateReward() public override {\n\t\t_updateRewardFor(_msgSender());\n\t}\n\n\tfunction updateRewardFor(address account) public override {\n\t\t_updateRewardFor(account);\n\t}\n\n\t/* Internal Views */\n\n\tfunction _getAccruedRewardsPerShare(uint256 _totalRewardsAccrued)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tif (_totalActiveShares == 0) {\n\t\t\treturn _accruedRewardsPerShare;\n\t\t}\n\n\t\t// Overflow is OK: delta is correct anyway\n\t\tuint256 delta = _totalRewardsAccrued - _lastTotalRewardsAccrued;\n\t\tif (delta == 0) {\n\t\t\treturn _accruedRewardsPerShare;\n\t\t}\n\n\t\t// Multiply by 1e18 for better rounding.\n\t\tuint256 rewardsPerShare = delta.mul(1e18).div(_totalActiveShares);\n\n\t\t// Overflow is OK\n\t\treturn _accruedRewardsPerShare + rewardsPerShare;\n\t}\n\n\tfunction _rewardsBalanceOfImpl(\n\t\taddress account,\n\t\tuint256 accruedRewardsPerShareParam\n\t) internal view virtual returns (uint256) {\n\t\t// Overflow is OK: delta is correct anyway\n\t\tuint256 accruedDelta =\n\t\t\taccruedRewardsPerShareParam - _accruedRewardsPerSharePaid[account];\n\n\t\t// Divide by 1e18 to convert to rewards decimals.\n\t\treturn\n\t\t\t_shares[account].active.mul(accruedDelta).div(1e18).add(\n\t\t\t\t_rewards[account]\n\t\t\t);\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _activate(address account) internal virtual {\n\t\tShares storage s = _shares[account];\n\n\t\t// Do nothing if already active\n\t\tif (s.active > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage d = _shares[_defaultRecipient];\n\n\t\ts.active = s.total;\n\t\td.active = d.active.sub(s.total).toUint128();\n\t\temit SharesActivated(account);\n\t}\n\n\tfunction _addShares(address account, uint128 amount) internal virtual {\n\t\tShares storage s = _shares[account];\n\t\tif (s.active == 0) {\n\t\t\t// Add to inactive value\n\t\t\tShares storage d = _shares[_defaultRecipient];\n\t\t\td.active = d.active.add(amount).toUint128();\n\t\t} else {\n\t\t\ts.active = s.active.add(amount).toUint128();\n\t\t}\n\t\ts.total = s.total.add(amount).toUint128();\n\t\temit SharesAdded(account, amount);\n\t}\n\n\tfunction _deactivate(address account) internal virtual {\n\t\t// Skip for the default recipient\n\t\tif (account == _defaultRecipient) {\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage s = _shares[account];\n\n\t\t// Do nothing if already deactivated\n\t\tif (s.active == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage d = _shares[_defaultRecipient];\n\n\t\ts.active = 0;\n\t\td.active = d.active.add(s.total).toUint128();\n\t\temit SharesDeactivated(account);\n\t}\n\n\tfunction _recoverUnsupportedERC20(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(\n\t\t\ttoken != rewardsToken,\n\t\t\t\"RewardsManagerAuto: cannot recover the rewards token\"\n\t\t);\n\t\ttoken.safeTransfer(to, amount);\n\t\temit RecoveredUnsupported(token, to, amount);\n\t}\n\n\tfunction _redeemAllRewards() internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\t_redeemRewardToImpl(account, account, _rewards[account]);\n\t}\n\n\tfunction _redeemRewardTo(address to, uint256 amount) internal virtual {\n\t\taddress from = _msgSender();\n\t\t_updateRewardFor(from);\n\t\trequire(\n\t\t\tamount <= _rewards[from],\n\t\t\t\"RewardsManagerAuto: cannot redeem more rewards than you have earned\"\n\t\t);\n\t\t_redeemRewardToImpl(from, to, amount);\n\t}\n\n\tfunction _redeemRewardToImpl(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual {\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\t\t// Overflow is OK\n\t\t_totalRewardsRedeemed += amount;\n\t\t_rewards[from] = _rewards[from].sub(amount);\n\t\trewardsToken.safeTransfer(to, amount);\n\t\temit RewardPaid(from, to, amount);\n\t}\n\n\tfunction _removeShares(address account, uint128 amount) internal virtual {\n\t\tShares storage s = _shares[account];\n\t\tif (s.active == 0) {\n\t\t\t// Remove from inactive value\n\t\t\tShares storage d = _shares[_defaultRecipient];\n\t\t\td.active = d.active.sub(amount).toUint128();\n\t\t} else {\n\t\t\ts.active = s.active.sub(amount).toUint128();\n\t\t}\n\t\ts.total = s.total.sub(amount).toUint128();\n\t\temit SharesRemoved(account, amount);\n\t}\n\n\tfunction _setDefaultRecipient(address account) internal virtual {\n\t\t// Activate\n\t\t_activate(account);\n\n\t\t// Move any inactive shares\n\t\t{\n\t\t\tShares storage original = _shares[_defaultRecipient];\n\t\t\tif (original.active > original.total) {\n\t\t\t\tuint128 inactive = original.active - original.total;\n\t\t\t\toriginal.active -= inactive;\n\n\t\t\t\tShares storage next = _shares[account];\n\t\t\t\tnext.active = next.active.add(inactive).toUint128();\n\t\t\t}\n\t\t}\n\n\t\t_defaultRecipient = account;\n\t\temit DefaultRecipientSet(account);\n\t}\n\n\tfunction _setShares(\n\t\taddress account,\n\t\tuint128 value,\n\t\tbool isActive\n\t) internal virtual {\n\t\tShares storage s = _shares[account];\n\t\tShares storage d = _shares[_defaultRecipient];\n\n\t\tif (s.active == 0) {\n\t\t\t// Subtract old inactive value\n\t\t\td.active = d.active.sub(s.total).toUint128();\n\t\t}\n\n\t\tif (!isActive) {\n\t\t\t// Add new inactive value\n\t\t\td.active = d.active.add(value).toUint128();\n\t\t} else {\n\t\t\ts.active = value;\n\t\t}\n\n\t\ts.total = value;\n\t\temit SharesSet(account, value);\n\t}\n\n\tfunction _updateAccrual() internal virtual {\n\t\tuint256 rewardsAccrued = totalRewardsAccrued();\n\t\t_accruedRewardsPerShare = _getAccruedRewardsPerShare(rewardsAccrued);\n\t\t_lastTotalRewardsAccrued = rewardsAccrued;\n\t}\n\n\tfunction _updateRewardFor(address account) internal virtual {\n\t\t_updateAccrual();\n\t\tuint256 arps = _accruedRewardsPerShare;\n\t\t// Gas savings since _updateAccrual does half the work\n\t\t_rewards[account] = _rewardsBalanceOfImpl(account, arps);\n\t\t_accruedRewardsPerSharePaid[account] = arps;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/rewards/interfaces/IRewardsManagerAuto.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRewardsManagerAuto {\n\t/* Views */\n\n\tfunction accruedRewardsPerShare() external view returns (uint256);\n\n\tfunction accruedRewardsPerSharePaid(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction defaultRecipient() external view returns (address);\n\n\tfunction rewardsBalanceOf(address account) external view returns (uint256);\n\n\tfunction rewardsToken() external view returns (IERC20);\n\n\tfunction sharesFor(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint128 active, uint128 total);\n\n\tfunction totalRewardsAccrued() external view returns (uint256);\n\n\tfunction totalRewardsRedeemed() external view returns (uint256);\n\n\tfunction totalShares() external view returns (uint128);\n\n\t/* Mutators */\n\n\tfunction activateShares() external;\n\n\tfunction activateSharesFor(address account) external;\n\n\tfunction addShares(address account, uint128 amount) external;\n\n\tfunction deactivateShares() external;\n\n\tfunction deactivateSharesFor(address account) external;\n\n\tfunction recoverUnsupportedERC20(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction redeemAllRewards() external;\n\n\tfunction redeemReward(uint256 amount) external;\n\n\tfunction redeemRewardTo(address to, uint256 amount) external;\n\n\tfunction removeShares(address account, uint128 amount) external;\n\n\tfunction setDefaultRecipient(address account) external;\n\n\tfunction setShares(\n\t\taddress account,\n\t\tuint128 value,\n\t\tbool isActive\n\t) external;\n\n\tfunction updateReward() external;\n\n\tfunction updateRewardFor(address account) external;\n\n\t/* Events */\n\n\tevent DefaultRecipientSet(address indexed account);\n\tevent RecoveredUnsupported(\n\t\tIERC20 indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RewardPaid(address indexed from, address indexed to, uint256 amount);\n\tevent SharesActivated(address indexed account);\n\tevent SharesAdded(address indexed account, uint128 amount);\n\tevent SharesDeactivated(address indexed account);\n\tevent SharesRemoved(address indexed account, uint128 amount);\n\tevent SharesSet(address indexed account, uint128 value);\n}\n"
    },
    "contracts/rewards/ManagedRewardsPoolInstant.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"./interfaces/IRewardsManagerAuto.sol\";\nimport \"./RewardsPoolInstant.sol\";\n\ncontract ManagedRewardsPoolInstant is RewardsPoolInstant {\n\t/* Mutable Internal State */\n\n\tIRewardsManagerAuto internal _manager;\n\n\t/* Constructor */\n\n\tconstructor(\n\t\tIERC20 _rewardsToken,\n\t\tIERC20 _stakingToken,\n\t\tuint8 _stakingTokenDecimals,\n\t\tIRewardsManagerAuto rewardsManager\n\t) RewardsPoolInstant(_rewardsToken, _stakingToken, _stakingTokenDecimals) {\n\t\t_manager = rewardsManager;\n\t}\n\n\t/* External Mutators */\n\n\tfunction setManager(IRewardsManagerAuto account) external onlyOwner {\n\t\t_manager = account;\n\t}\n\n\t/* Public Views */\n\n\tfunction manager() public view returns (IRewardsManagerAuto) {\n\t\treturn _manager;\n\t}\n\n\t/* Internal Views */\n\n\tfunction _currentRewardsBalance() internal view override returns (uint256) {\n\t\treturn _manager.rewardsBalanceOf(address(this));\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _stakeFrom(address account, uint256 amount) internal override {\n\t\tbool wasDeactivated = totalStaked() == 0;\n\t\tRewardsPool._stakeFrom(account, amount);\n\t\tif (wasDeactivated) {\n\t\t\t_manager.activateShares();\n\t\t}\n\t}\n\n\tfunction _transferRewards(address account, uint256 amount)\n\t\tinternal\n\t\toverride\n\t{\n\t\t_manager.redeemRewardTo(account, amount);\n\t}\n\n\tfunction _unstake(uint256 amount) internal override {\n\t\tRewardsPool._unstake(amount);\n\t\tif (totalStaked() == 0) {\n\t\t\t_manager.deactivateShares();\n\t\t}\n\t}\n}\n"
    },
    "contracts/rewards/RewardsPoolInstant.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"./RewardsPool.sol\";\n\ncontract RewardsPoolInstant is RewardsPool {\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\t/* Mutable Internal State */\n\n\tuint256 internal _accruedRewardsPerToken;\n\tmapping(address => uint256) internal _accruedRewardsPerTokenPaid;\n\tuint256 internal _lastTotalRewardsAccrued;\n\n\t/* Events */\n\n\tevent RecoveredUnredeemableRewards(address indexed to, uint256 amount);\n\n\t/* Constructor */\n\n\tconstructor(\n\t\tIERC20 _rewardsToken,\n\t\tIERC20 _stakingToken,\n\t\tuint8 _stakingTokenDecimals\n\t) RewardsPool(_rewardsToken, _stakingToken, _stakingTokenDecimals) {\n\t\treturn;\n\t}\n\n\t/* Public Views */\n\n\t// Represents a variable ratio of reward token to staking token accrued thus\n\t// far, multiplied by 10**stakingTokenDecimal in case of a fraction.\n\tfunction accruedRewardsPerToken() public view returns (uint256) {\n\t\treturn _getAccruedRewardsPerToken(totalRewardsAccrued());\n\t}\n\n\tfunction accruedRewardsPerTokenPaid(address account)\n\t\tpublic\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn _accruedRewardsPerTokenPaid[account];\n\t}\n\n\tfunction rewardsBalanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _rewardsBalanceOfImpl(account, accruedRewardsPerToken());\n\t}\n\n\tfunction unredeemableRewards() public view returns (uint256) {\n\t\treturn _rewards[address(0)];\n\t}\n\n\t/* Public Mutators */\n\n\t// In the event that rewards tokens are sent to the contract while there are\n\t// no stakers.\n\tfunction recoverUnredeemableRewards(address to, uint256 amount)\n\t\tpublic\n\t\tonlyOwner\n\t{\n\t\t_recoverUnredeemableRewards(to, amount);\n\t}\n\n\t/* Internal Views */\n\n\tfunction _getAccruedRewardsPerToken(uint256 _totalRewardsAccrued)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tuint256 totalStaked = totalStaked();\n\t\tif (totalStaked == 0) {\n\t\t\treturn _accruedRewardsPerToken;\n\t\t}\n\n\t\t// Overflow is OK: delta is correct anyway\n\t\tuint256 delta = _totalRewardsAccrued - _lastTotalRewardsAccrued;\n\t\tif (delta == 0) {\n\t\t\treturn _accruedRewardsPerToken;\n\t\t}\n\n\t\t// Multiply by stakingTokenBase for better rounding.\n\t\tuint256 rewardsPerToken =\n\t\t\tdelta.mul(_getStakingTokenBase()).div(totalStaked);\n\n\t\t// Overflow is OK\n\t\treturn _accruedRewardsPerToken + rewardsPerToken;\n\t}\n\n\tfunction _rewardsBalanceOfImpl(\n\t\taddress account,\n\t\tuint256 accruedRewardsPerTokenParam\n\t) internal view virtual returns (uint256) {\n\t\t// Overflow is OK: delta is correct anyway\n\t\tuint256 accruedDelta =\n\t\t\taccruedRewardsPerTokenParam - _accruedRewardsPerTokenPaid[account];\n\n\t\t// Divide by stakingTokenBase to convert to rewards decimals.\n\t\treturn\n\t\t\tstakedBalanceOf(account)\n\t\t\t\t.mul(accruedDelta)\n\t\t\t\t.div(_getStakingTokenBase())\n\t\t\t\t.add(_rewards[account]);\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _recoverUnredeemableRewards(address to, uint256 amount)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\tuint256 unredeemable = unredeemableRewards();\n\t\trequire(\n\t\t\tamount <= unredeemable,\n\t\t\t\"RewardsPoolInstant: cannot recover more rewards than are unredeemable\"\n\t\t);\n\t\t_rewards[address(0)] = unredeemable.sub(amount);\n\t\t_transferRewards(to, amount);\n\t\temit RecoveredUnredeemableRewards(to, amount);\n\t}\n\n\tfunction _updateAccrual() internal virtual {\n\t\tuint256 rewardsAccrued = totalRewardsAccrued();\n\n\t\t// Allow recovery of unredeemable rewards\n\t\tif (totalStaked() == 0) {\n\t\t\t// Overflow is OK: delta is the same anyway\n\t\t\tuint256 accruedDelta = rewardsAccrued - _lastTotalRewardsAccrued;\n\t\t\tif (accruedDelta > 0) {\n\t\t\t\t// Assign to 0 address\n\t\t\t\t_rewards[address(0)] = _rewards[address(0)].add(accruedDelta);\n\t\t\t}\n\t\t}\n\n\t\t// Update values\n\t\t_accruedRewardsPerToken = _getAccruedRewardsPerToken(rewardsAccrued);\n\t\t_lastTotalRewardsAccrued = rewardsAccrued;\n\t}\n\n\tfunction _updateRewardFor(address account) internal virtual override {\n\t\t_updateAccrual();\n\t\tuint256 arpt = _accruedRewardsPerToken;\n\t\t// Gas savings since _updateAccrual does half the work\n\t\t_rewards[account] = _rewardsBalanceOfImpl(account, arpt);\n\t\t_accruedRewardsPerTokenPaid[account] = arpt;\n\t}\n}\n"
    },
    "contracts/rewards/RewardsPool.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IRewardsPool.sol\";\n\nabstract contract RewardsPool is\n\tContext,\n\tReentrancyGuard,\n\tOwnable,\n\tPausable,\n\tIRewardsPool\n{\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\t/* Immutable Public State */\n\n\tIERC20 public immutable override rewardsToken;\n\tIERC20 public immutable override stakingToken;\n\tuint8 public immutable override stakingTokenDecimals;\n\n\t/* Mutable Internal State */\n\n\tmapping(address => uint256) internal _rewards;\n\tuint256 internal _rewardsRedeemed;\n\tmapping(address => uint256) internal _rewardsRedeemedBy;\n\tmapping(address => uint256) internal _staked;\n\tuint256 internal _totalStaked;\n\n\t/* Immutable Private State */\n\n\tuint256 private immutable _stakingTokenBase;\n\n\t/* Constructor */\n\n\tconstructor(\n\t\tIERC20 _rewardsToken,\n\t\tIERC20 _stakingToken,\n\t\tuint8 _stakingTokenDecimals\n\t) Ownable() {\n\t\t// Prevent overflow, though 76 would create a safe but unusable contract\n\t\trequire(\n\t\t\t_stakingTokenDecimals < (77 - 18),\n\t\t\t\"RewardsPool: staking token has far too many decimals\"\n\t\t);\n\n\t\trewardsToken = _rewardsToken;\n\n\t\tstakingToken = _stakingToken;\n\t\tstakingTokenDecimals = _stakingTokenDecimals;\n\t\t// Add some breathing room for more accurate rounding\n\t\t_stakingTokenBase = 10**(_stakingTokenDecimals + 18);\n\t}\n\n\t/* Public Views */\n\n\tfunction rewardsBalanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256);\n\n\tfunction rewardsRedeemedBy(address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _rewardsRedeemedBy[account];\n\t}\n\n\tfunction stakedBalanceOf(address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _staked[account];\n\t}\n\n\tfunction totalRewardsAccrued() public view override returns (uint256) {\n\t\t// Overflow is OK\n\t\treturn _currentRewardsBalance() + _rewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemed() public view override returns (uint256) {\n\t\treturn _rewardsRedeemed;\n\t}\n\n\tfunction totalStaked() public view override returns (uint256) {\n\t\treturn _totalStaked;\n\t}\n\n\t/* Public Mutators */\n\n\tfunction exit() public override nonReentrant {\n\t\t_exit();\n\t}\n\n\tfunction pause() public override onlyOwner {\n\t\t_pause();\n\t}\n\n\t// In the event that staking tokens are accidentally sent to the contract\n\t// without staking.\n\tfunction recoverUnstakedTokens(address to, uint256 amount)\n\t\tpublic\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_recoverUnstakedTokens(to, amount);\n\t}\n\n\t// In the unlikely event that unsupported tokens are successfully sent to the\n\t// contract. This will also allow for removal of airdropped tokens.\n\tfunction recoverUnsupportedERC20(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 amount\n\t) public override onlyOwner {\n\t\t_recoverUnsupportedERC20(token, to, amount);\n\t}\n\n\tfunction redeemAllRewards() public override nonReentrant {\n\t\t_redeemAllRewards();\n\t}\n\n\tfunction redeemReward(uint256 amount) public override nonReentrant {\n\t\t_redeemReward(amount);\n\t}\n\n\tfunction stake(uint256 amount) public override nonReentrant whenNotPaused {\n\t\t_stakeFrom(_msgSender(), amount);\n\t}\n\n\tfunction unpause() public override onlyOwner {\n\t\t_unpause();\n\t}\n\n\tfunction unstake(uint256 amount) public override nonReentrant {\n\t\t_unstake(amount);\n\t}\n\n\tfunction unstakeAll() public override nonReentrant {\n\t\t_unstakeAll();\n\t}\n\n\tfunction updateReward() public override nonReentrant {\n\t\t_updateRewardFor(_msgSender());\n\t}\n\n\tfunction updateRewardFor(address account) public override nonReentrant {\n\t\t_updateRewardFor(account);\n\t}\n\n\t/* Internal Views */\n\n\tfunction _currentRewardsBalance() internal view virtual returns (uint256) {\n\t\treturn rewardsToken.balanceOf(address(this));\n\t}\n\n\tfunction _getStakingTokenBase() internal view returns (uint256) {\n\t\treturn _stakingTokenBase;\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _exit() internal virtual {\n\t\t_unstakeAll();\n\t\t_redeemAllRewards();\n\t}\n\n\tfunction _recoverUnstakedTokens(address to, uint256 amount)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\tuint256 unstakedBalance =\n\t\t\tstakingToken.balanceOf(address(this)).sub(_totalStaked);\n\t\trequire(\n\t\t\tamount <= unstakedBalance,\n\t\t\t\"RewardsPool: cannot recover more tokens than are not staked\"\n\t\t);\n\t\tstakingToken.safeTransfer(to, amount);\n\t\temit RecoveredUnstaked(to, amount);\n\t}\n\n\tfunction _recoverUnsupportedERC20(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(\n\t\t\ttoken != stakingToken,\n\t\t\t\"RewardsPool: cannot recover the staking token\"\n\t\t);\n\t\trequire(\n\t\t\ttoken != rewardsToken,\n\t\t\t\"RewardsPool: cannot recover the rewards token\"\n\t\t);\n\t\ttoken.safeTransfer(to, amount);\n\t\temit RecoveredUnsupported(token, to, amount);\n\t}\n\n\tfunction _redeemAllRewards() internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\tuint256 amount = _rewards[account];\n\t\t_redeemRewardImpl(account, amount);\n\t}\n\n\tfunction _redeemReward(uint256 amount) internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\tuint256 reward = _rewards[account];\n\t\trequire(\n\t\t\tamount <= reward,\n\t\t\t\"RewardsPool: cannot redeem more rewards than you have earned\"\n\t\t);\n\t\t_redeemRewardImpl(account, amount);\n\t}\n\n\tfunction _redeemRewardImpl(address account, uint256 amount)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\t\t_rewards[account] = _rewards[account].sub(amount);\n\t\t// Overflow is OK\n\t\t_rewardsRedeemed += amount;\n\t\t_rewardsRedeemedBy[account] += amount;\n\t\t_transferRewards(account, amount);\n\t\temit RewardPaid(account, amount);\n\t}\n\n\tfunction _stakeFrom(address account, uint256 amount) internal virtual {\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsPool: cannot stake from the zero address\"\n\t\t);\n\t\trequire(amount > 0, \"RewardsPool: cannot stake zero\");\n\n\t\t// Prevent spending gas without having a balance\n\t\tuint256 balance = stakingToken.balanceOf(account);\n\t\trequire(amount <= balance, \"RewardsPool: cannot stake more than balance\");\n\n\t\t// Prevent spending gas without having an allowance\n\t\tuint256 allowance = stakingToken.allowance(account, address(this));\n\t\trequire(\n\t\t\tamount <= allowance,\n\t\t\t\"RewardsPool: cannot stake more than allowance\"\n\t\t);\n\n\t\t_updateRewardFor(account);\n\t\t_totalStaked = _totalStaked.add(amount);\n\t\t_staked[account] = _staked[account].add(amount);\n\t\tstakingToken.safeTransferFrom(account, address(this), amount);\n\t\temit Staked(account, amount);\n\t}\n\n\tfunction _transferRewards(address account, uint256 amount) internal virtual {\n\t\trewardsToken.safeTransfer(account, amount);\n\t}\n\n\tfunction _unstake(uint256 amount) internal virtual {\n\t\trequire(amount > 0, \"RewardsPool: cannot unstake zero\");\n\t\taddress account = _msgSender();\n\n\t\tuint256 staked = stakedBalanceOf(account);\n\t\trequire(\n\t\t\tamount <= staked,\n\t\t\t\"RewardsPool: cannot unstake more than staked balance\"\n\t\t);\n\n\t\t_updateRewardFor(account);\n\t\t_totalStaked = _totalStaked.sub(amount);\n\t\t_staked[account] = _staked[account].sub(amount);\n\t\tstakingToken.safeTransfer(account, amount);\n\t\temit Unstaked(account, amount);\n\t}\n\n\tfunction _unstakeAll() internal virtual {\n\t\t_unstake(_staked[_msgSender()]);\n\t}\n\n\tfunction _updateRewardFor(address account) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/Context.sol\";\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"./Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/rewards/interfaces/IRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRewardsPool {\n\t/* Views */\n\n\tfunction rewardsBalanceOf(address account) external view returns (uint256);\n\n\tfunction rewardsRedeemedBy(address account) external view returns (uint256);\n\n\tfunction rewardsToken() external view returns (IERC20);\n\n\tfunction stakedBalanceOf(address account) external view returns (uint256);\n\n\tfunction stakingToken() external view returns (IERC20);\n\n\tfunction stakingTokenDecimals() external view returns (uint8);\n\n\tfunction totalRewardsAccrued() external view returns (uint256);\n\n\tfunction totalRewardsRedeemed() external view returns (uint256);\n\n\tfunction totalStaked() external view returns (uint256);\n\n\t/* Mutators */\n\n\tfunction exit() external;\n\n\tfunction pause() external;\n\n\tfunction recoverUnstakedTokens(address to, uint256 amount) external;\n\n\tfunction recoverUnsupportedERC20(\n\t\tIERC20 token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction redeemAllRewards() external;\n\n\tfunction redeemReward(uint256 amount) external;\n\n\tfunction stake(uint256 amount) external;\n\n\tfunction unpause() external;\n\n\tfunction unstake(uint256 amount) external;\n\n\tfunction unstakeAll() external;\n\n\tfunction updateReward() external;\n\n\tfunction updateRewardFor(address account) external;\n\n\t/* Events */\n\n\tevent RecoveredUnsupported(\n\t\tIERC20 indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RecoveredUnstaked(address indexed to, uint256 amount);\n\tevent RewardPaid(address indexed account, uint256 amount);\n\tevent Staked(address indexed account, uint256 amount);\n\tevent Unstaked(address indexed account, uint256 amount);\n}\n"
    },
    "contracts/rewards/mocks/MockRewardsPoolInstant.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../RewardsPoolInstant.sol\";\n\ncontract MockRewardsPoolInstant is RewardsPoolInstant {\n\tconstructor(\n\t\tIERC20 _rewardsToken,\n\t\tIERC20 _stakingToken,\n\t\tuint8 _stakingTokenDecimals\n\t) RewardsPoolInstant(_rewardsToken, _stakingToken, _stakingTokenDecimals) {\n\t\treturn;\n\t}\n\n\t/* Public Views */\n\n\tfunction stakingTokenBase() public view returns (uint256) {\n\t\treturn _getStakingTokenBase();\n\t}\n\n\t/* Public Mutators */\n\n\tfunction setAccruedRewardsPerToken(uint256 value) public {\n\t\t_accruedRewardsPerToken = value;\n\t}\n\n\tfunction increaseAccruedRewardsPerToken(uint256 amount) public {\n\t\t_accruedRewardsPerToken += amount;\n\t}\n\n\tfunction setAccruedRewardsPerTokenPaid(address account, uint256 value)\n\t\tpublic\n\t{\n\t\t_accruedRewardsPerTokenPaid[account] = value;\n\t}\n\n\tfunction increaseAccruedRewardsPerTokenPaid(address account, uint256 amount)\n\t\tpublic\n\t{\n\t\t_accruedRewardsPerTokenPaid[account] += amount;\n\t}\n\n\tfunction setLastTotalRewardsAccrued(uint256 value) public {\n\t\t_lastTotalRewardsAccrued = value;\n\t}\n\n\tfunction increaseLastTotalRewardsAccrued(uint256 amount) public {\n\t\t_lastTotalRewardsAccrued += amount;\n\t}\n\n\tfunction setRewardsRedeemed(uint256 value) public {\n\t\t_rewardsRedeemed = value;\n\t}\n\n\tfunction increaseRewardsRedeemed(uint256 amount) public {\n\t\t_rewardsRedeemed += amount;\n\t}\n\n\tfunction setRewardsRedeemedBy(address account, uint256 value) public {\n\t\t_rewardsRedeemedBy[account] = value;\n\t}\n\n\tfunction increaseRewardsRedeemedBy(address account, uint256 amount) public {\n\t\t_rewardsRedeemedBy[account] += amount;\n\t}\n}\n"
    },
    "contracts/rewards/mocks/MockRewardsPool.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../RewardsPool.sol\";\n\ncontract MockRewardsPool is RewardsPool {\n\tconstructor(\n\t\tIERC20 _rewardsToken,\n\t\tIERC20 _stakingToken,\n\t\tuint8 _stakingTokenDecimals\n\t) RewardsPool(_rewardsToken, _stakingToken, _stakingTokenDecimals) {\n\t\treturn;\n\t}\n\n\tfunction rewardsBalanceOf(address) public pure override returns (uint256) {\n\t\treturn 0;\n\t}\n\n\tfunction stakingTokenBase() public view returns (uint256) {\n\t\treturn _getStakingTokenBase();\n\t}\n\n\tfunction _updateRewardFor(address) internal pure override {\n\t\treturn;\n\t}\n}\n"
    },
    "contracts/tokens/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0-solc-0.7/contracts/token/ERC20/ERC20.sol\n *\n * Changes:\n * - Change _balances, _allowances, and _totalSupply from private to internal\n * - Replace name, symbol, and decimals state with virtual functions.\n * - Make all functions virtual\n * - Reformat styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n\tusing SafeMath for uint256;\n\n\t/* Mutable Internal State */\n\n\tmapping(address => uint256) internal _balances;\n\n\tmapping(address => mapping(address => uint256)) internal _allowances;\n\n\tuint256 internal _totalSupply;\n\n\t/**\n\t * @dev Returns the name of the token. Overload it to change.\n\t */\n\tfunction name() public view virtual returns (string memory) {\n\t\treturn \"ERC20\";\n\t}\n\n\t/**\n\t * @dev Returns the symbol of the token, usually a shorter version of the\n\t * name. Overload it to change.\n\t */\n\tfunction symbol() public view virtual returns (string memory) {\n\t\treturn \"ERC20\";\n\t}\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * Tokens usually opt for a value of 18, imitating the relationship between\n\t * Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t * overridden;\n\t *\n\t * NOTE: This information is only used for _display_ purposes: it in\n\t * no way affects any of the arithmetic of the contract, including\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\n\t */\n\tfunction decimals() public view virtual returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {IERC20-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {IERC20-balanceOf}.\n\t */\n\tfunction balanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Requirements:\n\t *\n\t * - `recipient` cannot be the zero address.\n\t * - the caller must have a balance of at least `amount`.\n\t */\n\tfunction transfer(address recipient, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-allowance}.\n\t */\n\tfunction allowance(address owner, address spender)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev See {IERC20-approve}.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction approve(address spender, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP. See the note at the beginning of {ERC20}.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` and `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - the caller must have allowance for ``sender``'s tokens of at least\n\t * `amount`.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\t\t_approve(\n\t\t\tsender,\n\t\t\t_msgSender(),\n\t\t\t_allowances[sender][_msgSender()].sub(\n\t\t\t\tamount,\n\t\t\t\t\"ERC20: transfer amount exceeds allowance\"\n\t\t\t)\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically increases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].add(addedValue)\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t * - `spender` must have allowance for the caller of at least\n\t * `subtractedValue`.\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender].sub(\n\t\t\t\tsubtractedValue,\n\t\t\t\t\"ERC20: decreased allowance below zero\"\n\t\t\t)\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves tokens `amount` from `sender` to `recipient`.\n\t *\n\t * This is internal function is equivalent to {transfer}, and can be used to\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\t_balances[sender] = _balances[sender].sub(\n\t\t\tamount,\n\t\t\t\"ERC20: transfer amount exceeds balance\"\n\t\t);\n\n\t\t_balances[recipient] = _balances[recipient].add(amount);\n\n\t\temit Transfer(sender, recipient, amount);\n\t}\n\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t */\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\n\t\t_totalSupply = _totalSupply.add(amount);\n\t\t_balances[account] = _balances[account].add(amount);\n\t\temit Transfer(address(0), account, amount);\n\t}\n\n\t/**\n\t * @dev Destroys `amount` tokens from `account`, reducing the\n\t * total supply.\n\t *\n\t * Emits a {Transfer} event with `to` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t * - `account` must have at least `amount` tokens.\n\t */\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\t_balances[account] = _balances[account].sub(\n\t\t\tamount,\n\t\t\t\"ERC20: burn amount exceeds balance\"\n\t\t);\n\n\t\t_totalSupply = _totalSupply.sub(amount);\n\n\t\temit Transfer(account, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n\t *\n\t * This internal function is equivalent to `approve`, and can be used to\n\t * e.g. set automatic allowances for certain subsystems, etc.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev Hook that is called before any transfer of tokens. This includes\n\t * minting and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\t * will be to transferred to `to`.\n\t * - when `from` is zero, `amount` tokens will be minted for `to`.\n\t * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts. adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress, /* from */\n\t\taddress, /* to */\n\t\tuint256 /* amount */\n\t) internal virtual {\n\t\treturn;\n\t}\n}\n"
    },
    "contracts/tokens/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"../ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n\tstring private _name;\n\tstring private _symbol;\n\tuint8 private immutable _decimals;\n\n\tconstructor(\n\t\tstring memory name_,\n\t\tstring memory symbol_,\n\t\tuint8 decimals_,\n\t\tuint256 supply\n\t) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t\t_decimals = decimals_;\n\t\t_mint(msg.sender, supply);\n\t}\n\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\tfunction decimals() public view virtual override returns (uint8) {\n\t\treturn _decimals;\n\t}\n\n\tfunction mint(address account, uint256 amount) public {\n\t\t_mint(account, amount);\n\t}\n\n\tfunction mockMint(address account, uint256 amount) public {\n\t\t_mint(account, amount);\n\t}\n}\n"
    },
    "contracts/tokens/ERC20TxFee/ERC20TxFee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../ERC20/ERC20.sol\";\nimport \"../interfaces/IERC20TxFee.sol\";\nimport \"../../rewards/interfaces/IFeeLogic.sol\";\n\n/**\n * @dev Adds a transfer fee to {ERC20} using the {IFeeLogic} interface.\n */\nabstract contract ERC20TxFee is ERC20, IERC20TxFee {\n\tusing SafeMath for uint256;\n\n\t/* Mutable Internal State */\n\n\taddress internal _feeLogic;\n\n\t/* Constructor */\n\n\tconstructor(address feeLogic_) {\n\t\trequire(feeLogic_ != address(0), \"ERC20TxFee: feeLogic zero address\");\n\t\t_feeLogic = feeLogic_;\n\t}\n\n\t/* Public Views */\n\n\t/**\n\t * @dev Returns the feeLogic handler address.\n\t */\n\tfunction feeLogic() public view virtual override returns (address) {\n\t\treturn _feeLogic;\n\t}\n\n\t/* Internal Mutators */\n\n\t/**\n\t * @dev Overrides {ERC20-_transfer} to implement a fee on transfers.\n\t *\n\t * Emits a {Transfer} event. Emits a second {Transfer} event for the fee.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - `_feeLogic` implements {IFeeLogic}\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\t_balances[sender] = _balances[sender].sub(\n\t\t\tamount,\n\t\t\t\"ERC20: transfer amount exceeds balance\"\n\t\t);\n\n\t\tIFeeLogic feeHandler = IFeeLogic(_feeLogic);\n\t\tuint256 fee = feeHandler.getFee(sender, recipient, amount);\n\t\tuint256 amountSubFee = amount.sub(fee);\n\n\t\t_balances[recipient] = _balances[recipient].add(amountSubFee);\n\t\temit Transfer(sender, recipient, amountSubFee);\n\n\t\tif (fee != 0) {\n\t\t\taddress feeRecipient = feeHandler.recipient();\n\t\t\t_balances[feeRecipient] = _balances[feeRecipient].add(fee);\n\t\t\temit Transfer(sender, feeRecipient, fee);\n\t\t\tfeeHandler.notify(fee);\n\t\t}\n\t}\n}\n"
    },
    "contracts/tokens/mocks/MockERC20TxFee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../ERC20TxFee/ERC20TxFee.sol\";\n\ncontract MockERC20TxFee is ERC20TxFee {\n\tstring private _name;\n\tstring private _symbol;\n\tuint8 private immutable _decimals;\n\n\tevent BeforeTokenTransfer();\n\n\tconstructor(\n\t\tstring memory name_,\n\t\tstring memory symbol_,\n\t\tuint8 decimals_,\n\t\taddress feeLogic_\n\t) ERC20TxFee(feeLogic_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t\t_decimals = decimals_;\n\t}\n\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\tfunction decimals() public view virtual override returns (uint8) {\n\t\treturn _decimals;\n\t}\n\n\tfunction mint(address account, uint256 amount) public {\n\t\t_mint(account, amount);\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress, /* from */\n\t\taddress, /* to */\n\t\tuint256 /* amount */\n\t) internal override {\n\t\temit BeforeTokenTransfer();\n\t}\n}\n"
    },
    "contracts/exchanges/ETHtxAMM/ETHtxAMM.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ETHtxAMMData.sol\";\nimport \"../interfaces/IETHtxAMM.sol\";\nimport \"../../tokens/interfaces/IETHtx.sol\";\nimport \"../../tokens/interfaces/IERC20TxFee.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../../rewards/interfaces/IFeeLogic.sol\";\nimport \"../../oracles/interfaces/IGasPrice.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\n\ncontract ETHtxAMM is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tPausableUpgradeable,\n\tETHtxAMMData,\n\tIETHtxAMM\n{\n\tusing Address for address payable;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint128;\n\tusing SafeMath for uint256;\n\n\tstruct ETHtxAMMArgs {\n\t\taddress ethtx;\n\t\taddress gasOracle;\n\t\taddress weth;\n\t\tuint128 targetCRatioNum;\n\t\tuint128 targetCRatioDen;\n\t}\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializer */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t\t__Pausable_init_unchained();\n\t}\n\n\tfunction postInit(ETHtxAMMArgs memory _args) external virtual onlyOwner {\n\t\taddress sender = _msgSender();\n\n\t\t_ethtx = _args.ethtx;\n\t\temit ETHtxSet(sender, _args.ethtx);\n\n\t\t_gasOracle = _args.gasOracle;\n\t\temit GasOracleSet(sender, _args.gasOracle);\n\n\t\t_weth = _args.weth;\n\t\temit WETHSet(sender, _args.weth);\n\n\t\t_targetCRatioNum = _args.targetCRatioNum;\n\t\t_targetCRatioDen = _args.targetCRatioDen;\n\t\temit TargetCRatioSet(sender, _args.targetCRatioNum, _args.targetCRatioDen);\n\t}\n\n\t/* Fallbacks */\n\n\treceive() external payable {\n\t\t// Only accept ETH via fallback from the WETH contract\n\t\taddress weth_ = weth();\n\t\tif (msg.sender != weth_) {\n\t\t\t// Otherwise try to convert it to WETH\n\t\t\tIWETH(weth_).deposit{ value: msg.value }();\n\t\t}\n\t}\n\n\t/* Modifiers */\n\n\tmodifier ensure(uint256 deadline) {\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\trequire(deadline >= block.timestamp, \"ETHtxAMM: expired\");\n\t\t_;\n\t}\n\n\tmodifier priceIsFresh() {\n\t\trequire(\n\t\t\t!IGasPrice(gasOracle()).hasPriceExpired(),\n\t\t\t\"ETHtxAMM: gas price is outdated\"\n\t\t);\n\t\t_;\n\t}\n\n\t/* External Mutators */\n\n\tfunction swapEthForEthtx(uint256 deadline)\n\t\texternal\n\t\tpayable\n\t\tvirtual\n\t\toverride\n\t{\n\t\t_swapEthForEthtxRaw(msg.value, deadline, false);\n\t}\n\n\tfunction swapWethForEthtx(uint256 amountIn, uint256 deadline)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t{\n\t\t_swapEthForEthtxRaw(amountIn, deadline, true);\n\t}\n\n\tfunction swapEthForExactEthtx(uint256 amountOut, uint256 deadline)\n\t\texternal\n\t\tpayable\n\t\tvirtual\n\t\toverride\n\t{\n\t\tuint256 amountInMax = msg.value;\n\t\tuint256 amountIn =\n\t\t\t_swapEthForExactEthtx(amountInMax, amountOut, deadline, false);\n\t\t// refund leftover ETH\n\t\tif (amountInMax != amountIn) {\n\t\t\tpayable(_msgSender()).sendValue(amountInMax - amountIn);\n\t\t}\n\t}\n\n\tfunction swapWethForExactEthtx(\n\t\tuint256 amountInMax,\n\t\tuint256 amountOut,\n\t\tuint256 deadline\n\t) external virtual override {\n\t\t_swapEthForExactEthtx(amountInMax, amountOut, deadline, true);\n\t}\n\n\tfunction swapExactEthForEthtx(uint256 amountOutMin, uint256 deadline)\n\t\texternal\n\t\tpayable\n\t\tvirtual\n\t\toverride\n\t{\n\t\t_swapExactEthForEthtx(msg.value, amountOutMin, deadline, false);\n\t}\n\n\tfunction swapExactWethForEthtx(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\tuint256 deadline\n\t) external virtual override {\n\t\t_swapExactEthForEthtx(amountIn, amountOutMin, deadline, true);\n\t}\n\n\tfunction swapEthtxForEth(\n\t\tuint256 amountIn,\n\t\tuint256 deadline,\n\t\tbool asWETH\n\t) external virtual override ensure(deadline) priceIsFresh {\n\t\trequire(amountIn != 0, \"ETHtxAMM: cannot swap zero\");\n\t\tuint256 amountOut = exactEthtxToEth(amountIn);\n\t\t_swapEthtxForEth(_msgSender(), amountIn, amountOut, asWETH);\n\t}\n\n\tfunction swapEthtxForExactEth(\n\t\tuint256 amountInMax,\n\t\tuint256 amountOut,\n\t\tuint256 deadline,\n\t\tbool asWETH\n\t) external virtual override ensure(deadline) priceIsFresh {\n\t\trequire(amountInMax != 0, \"ETHtxAMM: cannot swap zero\");\n\t\tuint256 amountIn = ethtxToExactEth(amountOut);\n\t\trequire(amountIn <= amountInMax, \"ETHtxAMM: amountIn exceeds max\");\n\t\t_swapEthtxForEth(_msgSender(), amountIn, amountOut, asWETH);\n\t}\n\n\tfunction swapExactEthtxForEth(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\tuint256 deadline,\n\t\tbool asWETH\n\t) external virtual override ensure(deadline) priceIsFresh {\n\t\trequire(amountIn != 0, \"ETHtxAMM: cannot swap zero\");\n\t\tuint256 amountOut = exactEthtxToEth(amountIn);\n\t\trequire(amountOut >= amountOutMin, \"ETHtxAMM: amountOut below min\");\n\t\t_swapEthtxForEth(_msgSender(), amountIn, amountOut, asWETH);\n\t}\n\n\tfunction pause() external virtual override onlyOwner whenNotPaused {\n\t\t_pause();\n\t}\n\n\tfunction recoverUnsupportedERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyOwner {\n\t\trequire(token != weth(), \"ETHtxAMM: cannot recover WETH\");\n\t\trequire(token != ethtx(), \"ETHtxAMM: cannot recover ETHtx\");\n\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit RecoveredUnsupported(_msgSender(), token, to, amount);\n\t}\n\n\tfunction setEthtx(address account) public virtual override onlyOwner {\n\t\trequire(account != address(0), \"ETHtxAMM: ETHtx zero address\");\n\t\t_ethtx = account;\n\t\temit ETHtxSet(_msgSender(), account);\n\t}\n\n\tfunction setGasOracle(address account) public virtual override onlyOwner {\n\t\trequire(account != address(0), \"ETHtxAMM: gasOracle zero address\");\n\t\t_gasOracle = account;\n\t\temit GasOracleSet(_msgSender(), account);\n\t}\n\n\tfunction setTargetCRatio(uint128 numerator, uint128 denominator)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(numerator != 0, \"ETHtxAMM: targetCRatio numerator is zero\");\n\t\trequire(denominator != 0, \"ETHtxAMM: targetCRatio denominator is zero\");\n\t\t_targetCRatioNum = numerator;\n\t\t_targetCRatioDen = denominator;\n\t\temit TargetCRatioSet(_msgSender(), numerator, denominator);\n\t}\n\n\tfunction setWETH(address account) public virtual override onlyOwner {\n\t\trequire(account != address(0), \"ETHtxAMM: WETH zero address\");\n\t\t_weth = account;\n\t\temit WETHSet(_msgSender(), account);\n\t}\n\n\tfunction unpause() external virtual override onlyOwner whenPaused {\n\t\t_unpause();\n\t}\n\n\t/* Public Pure */\n\n\tfunction gasPerETHtx() public pure virtual override returns (uint256) {\n\t\treturn 21000; // Per 1e18\n\t}\n\n\t/* Public Views */\n\n\tfunction cRatio()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256 numerator, uint256 denominator)\n\t{\n\t\tnumerator = ethSupply();\n\t\tdenominator = ethToExactEthtx(ethtxOutstanding());\n\t}\n\n\tfunction cRatioBelowTarget() public view virtual override returns (bool) {\n\t\t(uint256 cRatioNum, uint256 cRatioDen) = cRatio();\n\t\tif (cRatioDen == 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tuint256 current = cRatioNum.mul(1e18) / cRatioDen;\n\n\t\t(uint256 targetNum, uint256 targetDen) = targetCRatio();\n\t\tuint256 target = targetNum.mul(1e18).div(targetDen);\n\n\t\treturn current < target;\n\t}\n\n\tfunction ethNeeded() external view virtual override returns (uint256) {\n\t\t(uint256 ethSupply_, uint256 ethOut) = cRatio();\n\t\t(uint128 targetNum, uint128 targetDen) = targetCRatio();\n\n\t\tuint256 target = ethOut.mul(targetNum).div(targetDen);\n\n\t\tif (ethSupply_ > target) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn target - ethSupply_;\n\t}\n\n\tfunction ethtx() public view virtual override returns (address) {\n\t\treturn _ethtx;\n\t}\n\n\tfunction exactEthToEthtx(uint256 amountEthIn)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _ethToEthtx(gasPrice(), amountEthIn);\n\t}\n\n\tfunction ethToExactEthtx(uint256 amountEthtxOut)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _ethtxToEth(gasPrice(), amountEthtxOut);\n\t}\n\n\tfunction exactEthtxToEth(uint256 amountEthtxIn)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Account for fee\n\t\tuint256 fee =\n\t\t\tIFeeLogic(feeLogic()).getFee(_msgSender(), address(this), amountEthtxIn);\n\n\t\treturn _ethtxToEth(gasPriceAtRedemption(), amountEthtxIn.sub(fee));\n\t}\n\n\tfunction ethtxToExactEth(uint256 amountEthOut)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tuint256 amountEthtx = _ethToEthtx(gasPriceAtRedemption(), amountEthOut);\n\n\t\t// Account for fee\n\t\tuint256 amountBeforeFee =\n\t\t\tIFeeLogic(feeLogic()).undoFee(_msgSender(), address(this), amountEthtx);\n\n\t\treturn amountBeforeFee;\n\t}\n\n\tfunction ethSupply() public view virtual override returns (uint256) {\n\t\treturn IERC20(weth()).balanceOf(address(this));\n\t}\n\n\tfunction ethSupplyTarget() external view virtual override returns (uint256) {\n\t\t(uint128 targetNum, uint128 targetDen) = targetCRatio();\n\t\treturn ethToExactEthtx(ethtxOutstanding()).mul(targetNum).div(targetDen);\n\t}\n\n\tfunction ethtxAvailable() public view virtual override returns (uint256) {\n\t\treturn IERC20(ethtx()).balanceOf(address(this));\n\t}\n\n\tfunction ethtxOutstanding() public view virtual override returns (uint256) {\n\t\treturn IERC20(ethtx()).totalSupply().sub(ethtxAvailable());\n\t}\n\n\tfunction feeLogic() public view virtual override returns (address) {\n\t\treturn IERC20TxFee(ethtx()).feeLogic();\n\t}\n\n\tfunction gasOracle() public view virtual override returns (address) {\n\t\treturn _gasOracle;\n\t}\n\n\tfunction gasPrice() public view virtual override returns (uint256) {\n\t\treturn IGasPrice(gasOracle()).gasPrice();\n\t}\n\n\tfunction gasPriceAtRedemption()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Apply cap when collateral below target\n\t\tuint256 gasPrice_ = gasPrice();\n\t\tuint256 maxGasPrice_ = maxGasPrice();\n\t\tif (gasPrice_ > maxGasPrice_) {\n\t\t\tgasPrice_ = maxGasPrice_;\n\t\t}\n\t\treturn gasPrice_;\n\t}\n\n\tfunction maxGasPrice() public view virtual override returns (uint256) {\n\t\tuint256 liability = ethtxOutstanding();\n\t\tif (liability == 0) {\n\t\t\treturn gasPrice();\n\t\t}\n\n\t\t(uint128 targetNum, uint128 targetDen) = targetCRatio();\n\n\t\tuint256 numerator = ethSupply().mul(1e18).mul(targetDen);\n\t\tuint256 denominator = liability.mul(gasPerETHtx()).mul(targetNum);\n\t\treturn numerator.div(denominator);\n\t}\n\n\tfunction targetCRatio()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint128 numerator, uint128 denominator)\n\t{\n\t\tnumerator = _targetCRatioNum;\n\t\tdenominator = _targetCRatioDen;\n\t}\n\n\tfunction weth() public view virtual override returns (address) {\n\t\treturn _weth;\n\t}\n\n\t/* Internal Pure */\n\n\tfunction _ethtxToEth(uint256 gasPrice_, uint256 amountETHtx)\n\t\tinternal\n\t\tpure\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\treturn gasPrice_.mul(amountETHtx).mul(gasPerETHtx()) / 1e18;\n\t}\n\n\tfunction _ethToEthtx(uint256 gasPrice_, uint256 amountETH)\n\t\tinternal\n\t\tpure\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\trequire(gasPrice_ != 0, \"ETHtxAMM: gasPrice is zero\");\n\t\treturn amountETH.mul(1e18) / gasPrice_.mul(gasPerETHtx());\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _swapEthForEthtxRaw(\n\t\tuint256 amountIn,\n\t\tuint256 deadline,\n\t\tbool useWETH\n\t) internal virtual ensure(deadline) priceIsFresh {\n\t\trequire(amountIn != 0, \"ETHtxAMM: cannot swap zero\");\n\t\tuint256 amountOut = exactEthToEthtx(amountIn);\n\t\t_swapEthForEthtx(_msgSender(), amountIn, amountOut, useWETH);\n\t}\n\n\tfunction _swapEthForExactEthtx(\n\t\tuint256 amountInMax,\n\t\tuint256 amountOut,\n\t\tuint256 deadline,\n\t\tbool useWETH\n\t) internal virtual ensure(deadline) priceIsFresh returns (uint256 amountIn) {\n\t\trequire(amountInMax != 0, \"ETHtxAMM: cannot swap zero\");\n\t\t// Add 1 to account for rounding (can't get ETHtx for 0 wei)\n\t\tamountIn = ethToExactEthtx(amountOut).add(1);\n\t\trequire(amountIn <= amountInMax, \"ETHtxAMM: amountIn exceeds max\");\n\t\t_swapEthForEthtx(_msgSender(), amountIn, amountOut, useWETH);\n\t}\n\n\tfunction _swapExactEthForEthtx(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\tuint256 deadline,\n\t\tbool useWETH\n\t) internal virtual ensure(deadline) priceIsFresh {\n\t\trequire(amountIn != 0, \"ETHtxAMM: cannot swap zero\");\n\t\tuint256 amountOut = exactEthToEthtx(amountIn);\n\t\trequire(amountOut >= amountOutMin, \"ETHtxAMM: amountOut below min\");\n\t\t_swapEthForEthtx(_msgSender(), amountIn, amountOut, useWETH);\n\t}\n\n\tfunction _swapEthForEthtx(\n\t\taddress account,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut,\n\t\tbool useWETH\n\t) internal virtual {\n\t\tuint256 availableSupply = IERC20(ethtx()).balanceOf(address(this));\n\t\trequire(\n\t\t\tavailableSupply >= amountOut,\n\t\t\t\"ETHtxAMM: not enough ETHtx available\"\n\t\t);\n\n\t\tif (useWETH) {\n\t\t\tIERC20(weth()).safeTransferFrom(account, address(this), amountIn);\n\t\t} else {\n\t\t\tIWETH(weth()).deposit{ value: amountIn }();\n\t\t}\n\n\t\t// Bypass fee by setting exemption for AMM contract\n\t\tIERC20(ethtx()).safeTransfer(account, amountOut);\n\t}\n\n\tfunction _swapEthtxForEth(\n\t\taddress account,\n\t\tuint256 amountIn,\n\t\tuint256 amountOut,\n\t\tbool asWETH\n\t) internal virtual {\n\t\t// Apply fee\n\t\tIERC20(ethtx()).safeTransferFrom(account, address(this), amountIn);\n\n\t\tif (asWETH) {\n\t\t\tIERC20(weth()).safeTransfer(account, amountOut);\n\t\t} else {\n\t\t\tIWETH(weth()).withdraw(amountOut);\n\t\t\tpayable(account).sendValue(amountOut);\n\t\t}\n\t}\n}\n"
    },
    "contracts/exchanges/ETHtxAMM/ETHtxAMMData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ETHtxAMMData {\n\taddress internal _gasOracle;\n\tuint128 internal _targetCRatioNum;\n\tuint128 internal _targetCRatioDen;\n\taddress internal _ethtx;\n\taddress internal _weth;\n\n\tuint256[46] private __gap;\n}\n"
    },
    "contracts/exchanges/interfaces/IETHtxAMM.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IETHtxAMM {\n\t/* Views */\n\n\tfunction cRatio()\n\t\texternal\n\t\tview\n\t\treturns (uint256 numerator, uint256 denominator);\n\n\tfunction cRatioBelowTarget() external view returns (bool);\n\n\tfunction ethNeeded() external view returns (uint256);\n\n\tfunction ethtx() external view returns (address);\n\n\tfunction exactEthToEthtx(uint256 amountEthIn)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction ethToExactEthtx(uint256 amountEthtxOut)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction exactEthtxToEth(uint256 amountEthtxIn)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction ethtxToExactEth(uint256 amountEthOut)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction ethSupply() external view returns (uint256);\n\n\tfunction ethSupplyTarget() external view returns (uint256);\n\n\tfunction ethtxAvailable() external view returns (uint256);\n\n\tfunction ethtxOutstanding() external view returns (uint256);\n\n\tfunction feeLogic() external view returns (address);\n\n\tfunction gasOracle() external view returns (address);\n\n\tfunction gasPerETHtx() external pure returns (uint256);\n\n\tfunction gasPrice() external view returns (uint256);\n\n\tfunction gasPriceAtRedemption() external view returns (uint256);\n\n\tfunction maxGasPrice() external view returns (uint256);\n\n\tfunction targetCRatio()\n\t\texternal\n\t\tview\n\t\treturns (uint128 numerator, uint128 denominator);\n\n\tfunction weth() external view returns (address);\n\n\t/* Mutators */\n\n\tfunction swapEthForEthtx(uint256 deadline) external payable;\n\n\tfunction swapWethForEthtx(uint256 amountIn, uint256 deadline) external;\n\n\tfunction swapEthForExactEthtx(uint256 amountOut, uint256 deadline)\n\t\texternal\n\t\tpayable;\n\n\tfunction swapWethForExactEthtx(\n\t\tuint256 amountInMax,\n\t\tuint256 amountOut,\n\t\tuint256 deadline\n\t) external;\n\n\tfunction swapExactEthForEthtx(uint256 amountOutMin, uint256 deadline)\n\t\texternal\n\t\tpayable;\n\n\tfunction swapExactWethForEthtx(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\tuint256 deadline\n\t) external;\n\n\tfunction swapEthtxForEth(\n\t\tuint256 amountIn,\n\t\tuint256 deadline,\n\t\tbool asWETH\n\t) external;\n\n\tfunction swapEthtxForExactEth(\n\t\tuint256 amountInMax,\n\t\tuint256 amountOut,\n\t\tuint256 deadline,\n\t\tbool asWETH\n\t) external;\n\n\tfunction swapExactEthtxForEth(\n\t\tuint256 amountIn,\n\t\tuint256 amountOutMin,\n\t\tuint256 deadline,\n\t\tbool asWETH\n\t) external;\n\n\tfunction pause() external;\n\n\tfunction recoverUnsupportedERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction setEthtx(address account) external;\n\n\tfunction setGasOracle(address account) external;\n\n\tfunction setTargetCRatio(uint128 numerator, uint128 denominator) external;\n\n\tfunction setWETH(address account) external;\n\n\tfunction unpause() external;\n\n\t/* Events */\n\n\tevent ETHtxSet(address indexed author, address indexed account);\n\tevent GasOracleSet(address indexed author, address indexed account);\n\tevent RecoveredUnsupported(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent TargetCRatioSet(\n\t\taddress indexed author,\n\t\tuint128 numerator,\n\t\tuint128 denominator\n\t);\n\tevent WETHSet(address indexed author, address indexed account);\n}\n"
    },
    "contracts/oracles/interfaces/IGasPrice.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IGasPrice {\n\t/* Views */\n\n\tfunction gasPrice() external view returns (uint256);\n\n\tfunction hasPriceExpired() external view returns (bool);\n\n\tfunction updateThreshold() external view returns (uint256);\n\n\tfunction updatedAt() external view returns (uint256);\n\n\t/* Mutators */\n\n\tfunction setGasPrice(uint256 _gasPrice) external;\n\n\tfunction setUpdateThreshold(uint256 _updateThreshold) external;\n\n\t/* Events */\n\n\tevent GasPriceUpdate(address indexed author, uint256 newValue);\n\tevent UpdateThresholdSet(address indexed author, uint256 value);\n}\n"
    },
    "contracts/oracles/GasPrice.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IGasPrice.sol\";\n\n// Accuracy in block.timestamp is not needed.\n// https://consensys.github.io/smart-contract-best-practices/recommendations/#the-15-second-rule\n/* solhint-disable not-rely-on-time */\n\ncontract GasPrice is AccessControl, IGasPrice {\n\tusing SafeMath for uint256;\n\n\tbytes32 public constant ORACLE_ROLE = keccak256(\"ORACLE_ROLE\");\n\tuint256 public override gasPrice;\n\tuint256 public override updateThreshold;\n\tuint256 public override updatedAt;\n\n\tconstructor(\n\t\taddress admin,\n\t\tuint256 _updateThreshold,\n\t\tuint256 _gasPrice\n\t) {\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, admin);\n\t\t_setUpdateThreshold(_updateThreshold);\n\t\t_setGasPrice(_gasPrice);\n\t}\n\n\tfunction setGasPrice(uint256 _gasPrice) external override {\n\t\trequire(\n\t\t\thasRole(ORACLE_ROLE, msg.sender),\n\t\t\t\"Caller is not a trusted oracle source.\"\n\t\t);\n\t\t_setGasPrice(_gasPrice);\n\t}\n\n\tfunction setUpdateThreshold(uint256 _updateThreshold) external override {\n\t\trequire(\n\t\t\thasRole(DEFAULT_ADMIN_ROLE, msg.sender),\n\t\t\t\"Caller is not the contract admin.\"\n\t\t);\n\t\t_setUpdateThreshold(_updateThreshold);\n\t}\n\n\tfunction hasPriceExpired() external view override returns (bool) {\n\t\tuint256 timePassed =\n\t\t\tblock.timestamp.sub(\n\t\t\t\tupdatedAt,\n\t\t\t\t\"GasPrice: block is older than last update\"\n\t\t\t);\n\t\treturn timePassed > updateThreshold;\n\t}\n\n\tfunction _setGasPrice(uint256 _gasPrice) internal {\n\t\t// update public values\n\t\tupdatedAt = block.timestamp;\n\t\tgasPrice = _gasPrice;\n\t\temit GasPriceUpdate(msg.sender, _gasPrice);\n\t}\n\n\tfunction _setUpdateThreshold(uint256 _updateThreshold) internal {\n\t\tupdateThreshold = _updateThreshold;\n\t\temit UpdateThresholdSet(msg.sender, _updateThreshold);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\nimport \"../utils/EnumerableSet.sol\";\nimport \"../utils/Address.sol\";\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using Address for address;\n\n    struct RoleData {\n        EnumerableSet.AddressSet members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view returns (bool) {\n        return _roles[role].members.contains(account);\n    }\n\n    /**\n     * @dev Returns the number of accounts that have `role`. Can be used\n     * together with {getRoleMember} to enumerate all bearers of a role.\n     */\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\n        return _roles[role].members.length();\n    }\n\n    /**\n     * @dev Returns one of the accounts that have `role`. `index` must be a\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\n     *\n     * Role bearers are not sorted in any particular way, and their ordering may\n     * change at any point.\n     *\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n     * you perform all queries on the same block. See the following\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n     * for more information.\n     */\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n        return _roles[role].members.at(index);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to grant\");\n\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual {\n        require(hasRole(_roles[role].adminRole, _msgSender()), \"AccessControl: sender must be an admin to revoke\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (_roles[role].members.add(account)) {\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (_roles[role].members.remove(account)) {\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "contracts/oracles/mocks/MockGasPrice.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../GasPrice.sol\";\n\ncontract MockGasPrice is GasPrice {\n\tconstructor(\n\t\taddress admin,\n\t\tuint256 _updateThreshold,\n\t\tuint256 _gasPrice\n\t) GasPrice(admin, _updateThreshold, _gasPrice) {\n\t\treturn;\n\t}\n\n\tfunction setUpdatedAt(uint256 value) external {\n\t\tupdatedAt = value;\n\t}\n}\n"
    },
    "contracts/rewards/LPRewardsAuto.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"../libraries/EnumerableMap.sol\";\nimport \"./interfaces/ILPRewardsAuto.sol\";\nimport \"./interfaces/IValuePerToken.sol\";\n\ncontract LPRewardsAuto is Ownable, Pausable, ReentrancyGuard, ILPRewardsAuto {\n\tusing EnumerableMap for EnumerableMap.AddressToUintMap;\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\t/* Structs */\n\n\tstruct TokenData {\n\t\tuint256 accruedRewardsPerToken;\n\t\tuint256 lastRewardsAccrued;\n\t\tuint256 rewards;\n\t\tuint256 rewardsRedeemed;\n\t\tuint256 totalStaked;\n\t\taddress valueImpl;\n\t}\n\n\tstruct UserTokenRewards {\n\t\tuint256 pending;\n\t\tuint256 redeemed;\n\t\tuint256 accruedPerTokenPaid;\n\t}\n\n\tstruct UserData {\n\t\tuint256 totalRewards;\n\t\tuint256 totalRedeemed;\n\t\tEnumerableSet.AddressSet tokensWithRewards;\n\t\tmapping(address => UserTokenRewards) rewards;\n\t\tEnumerableMap.AddressToUintMap staked;\n\t}\n\n\t/* Immutable Public State */\n\taddress public immutable override rewardsToken;\n\n\t/* Immutable Internal State */\n\n\tuint256 internal constant _MULTIPLIER = 1e36;\n\n\t/* Mutable Internal State */\n\n\tuint256 internal _lastTotalRewardsAccrued;\n\tuint256 internal _totalRewardsRedeemed;\n\tEnumerableSet.AddressSet internal _tokens;\n\tmapping(address => TokenData) internal _tokenData;\n\tmapping(address => UserData) internal _users;\n\n\t/* Constructor */\n\n\tconstructor(address _rewardsToken) Ownable() {\n\t\trewardsToken = _rewardsToken;\n\t}\n\n\t/* External Views */\n\n\tfunction currentAccruedRewardsPerTokenFor(address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn\n\t\t\t_getAccruedRewardsPerTokenFor(\n\t\t\t\ttoken,\n\t\t\t\tthis.currentTotalRewardsAccruedFor(token)\n\t\t\t);\n\t}\n\n\tfunction currentRewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Get current pending rewards.\n\t\tuint256 totalPending = totalRewardsAccrued() - _lastTotalRewardsAccrued;\n\t\tif (totalPending == 0) {\n\t\t\treturn this.rewardsBalanceOf(account);\n\t\t}\n\n\t\t// Expensive operation, so duplicate return\n\t\tuint256 totalShares = _totalShares();\n\t\tif (totalShares == 0) {\n\t\t\treturn this.rewardsBalanceOf(account);\n\t\t}\n\n\t\tUserData storage user = _users[account];\n\t\tuint256 total = user.totalRewards;\n\n\t\t// WARNING: Be careful adding too many tokens.\n\t\tfor (uint256 i = 0; i < user.staked.length(); i++) {\n\t\t\t(address token, ) = user.staked.at(i);\n\n\t\t\t// Calculate current total rewards accrued for token\n\t\t\tuint256 shares = _totalSharesFor(token);\n\t\t\tuint256 pending = totalPending.mul(shares).div(totalShares);\n\t\t\tuint256 accrued = pending + totalRewardsAccruedFor(token);\n\n\t\t\tuint256 arpt = _getAccruedRewardsPerTokenFor(token, accrued);\n\n\t\t\ttotal = total.add(_pendingRewardsOfFor(account, token, arpt));\n\t\t}\n\n\t\treturn total;\n\t}\n\n\tfunction currentRewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tuint256 arpt = this.currentAccruedRewardsPerTokenFor(token);\n\t\tuint256 rewards = _users[account].rewards[token].pending;\n\t\treturn rewards.add(_pendingRewardsOfFor(account, token, arpt));\n\t}\n\n\tfunction currentSharesFor(address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(_tokens.contains(token), \"LPRewardsAuto: token not supported\");\n\t\treturn _totalSharesFor(token);\n\t}\n\n\tfunction currentSharesOf(address account)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 total)\n\t{\n\t\tUserData storage user = _users[account];\n\t\t// WARNING: Be careful adding too many tokens.\n\t\tfor (uint256 i = 0; i < user.staked.length(); i++) {\n\t\t\t(address token, uint256 amount) = user.staked.at(i);\n\t\t\ttotal = total.add(_shares(token, amount));\n\t\t}\n\t\treturn total;\n\t}\n\n\tfunction currentSharesOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(_tokens.contains(token), \"LPRewardsAuto: token not supported\");\n\t\treturn _shares(token, stakedBalanceOfFor(account, token));\n\t}\n\n\tfunction currentSharesPerTokenFor(address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(_tokens.contains(token), \"LPRewardsAuto: token not supported\");\n\t\treturn _shares(token, 1);\n\t}\n\n\tfunction currentTotalRewardsAccruedFor(address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tuint256 lastRewardsAccrued = totalRewardsAccruedFor(token);\n\n\t\t// Get current pending rewards.\n\t\tuint256 totalPending = totalRewardsAccrued() - _lastTotalRewardsAccrued;\n\t\tif (totalPending == 0) {\n\t\t\treturn lastRewardsAccrued;\n\t\t}\n\n\t\t// Divide pending by share\n\t\tuint256 totalShares = _totalShares();\n\t\tif (totalShares == 0) {\n\t\t\treturn lastRewardsAccrued;\n\t\t}\n\t\tuint256 shares = _totalSharesFor(token);\n\t\tuint256 pending = totalPending.mul(shares).div(totalShares);\n\n\t\t// Overflow is OK\n\t\treturn pending + lastRewardsAccrued;\n\t}\n\n\tfunction currentTotalShares() external view override returns (uint256) {\n\t\treturn _totalShares();\n\t}\n\n\tfunction numStakingTokens() external view override returns (uint256) {\n\t\treturn _tokens.length();\n\t}\n\n\tfunction rewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tUserData storage user = _users[account];\n\t\tuint256 total = user.totalRewards;\n\t\t// WARNING: Be careful adding too many tokens.\n\t\tfor (uint256 i = 0; i < user.staked.length(); i++) {\n\t\t\t(address token, ) = user.staked.at(i);\n\t\t\tuint256 arpt = accruedRewardsPerTokenFor(token);\n\t\t\ttotal = total.add(_pendingRewardsOfFor(account, token, arpt));\n\t\t}\n\t\treturn total;\n\t}\n\n\tfunction rewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tuint256 arpt = accruedRewardsPerTokenFor(token);\n\t\tuint256 rewards = _users[account].rewards[token].pending;\n\t\treturn rewards.add(_pendingRewardsOfFor(account, token, arpt));\n\t}\n\n\tfunction rewardsFor(address token) external view override returns (uint256) {\n\t\treturn _tokenData[token].rewards;\n\t}\n\n\tfunction rewardsRedeemedBy(address account)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _users[account].totalRedeemed;\n\t}\n\n\tfunction rewardsRedeemedByFor(address account, address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _users[account].rewards[token].redeemed;\n\t}\n\n\tfunction stakingTokenAt(uint256 index)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _tokens.at(index);\n\t}\n\n\tfunction supportsStakingToken(address token)\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _tokens.contains(token);\n\t}\n\n\t/* External Mutators */\n\n\tfunction addToken(address token, address tokenValueImpl)\n\t\texternal\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_addToken(token, tokenValueImpl);\n\t}\n\n\tfunction changeTokenValueImpl(address token, address tokenValueImpl)\n\t\texternal\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_changeTokenValueImpl(token, tokenValueImpl);\n\t}\n\n\tfunction exit() external override nonReentrant {\n\t\t_exit();\n\t}\n\n\tfunction exitFrom(address token) external override nonReentrant {\n\t\t_exitFrom(token);\n\t}\n\n\tfunction pause() external override onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction recoverUnstaked(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external override onlyOwner {\n\t\t_recoverUnstaked(token, to, amount);\n\t}\n\n\tfunction redeemAllRewards() external override nonReentrant {\n\t\t_redeemAllRewards();\n\t}\n\n\tfunction redeemAllRewardsFrom(address token) external override nonReentrant {\n\t\t_redeemAllRewardsFrom(token);\n\t}\n\n\tfunction redeemReward(uint256 amount) external override nonReentrant {\n\t\t_redeemReward(amount);\n\t}\n\n\tfunction redeemRewardFrom(address token, uint256 amount)\n\t\texternal\n\t\toverride\n\t\tnonReentrant\n\t{\n\t\t_redeemRewardFrom(token, amount);\n\t}\n\n\tfunction removeToken(address token) external override onlyOwner {\n\t\t_removeToken(token);\n\t}\n\n\tfunction stake(address token, uint256 amount)\n\t\texternal\n\t\toverride\n\t\tnonReentrant\n\t\twhenNotPaused\n\t{\n\t\t_stake(token, amount);\n\t}\n\n\tfunction unpause() external override onlyOwner {\n\t\t_unpause();\n\t}\n\n\tfunction unstake(address token, uint256 amount)\n\t\texternal\n\t\toverride\n\t\tnonReentrant\n\t{\n\t\t_unstake(token, amount);\n\t}\n\n\tfunction unstakeAll() external override nonReentrant {\n\t\t_unstakeAll();\n\t}\n\n\tfunction unstakeAllFrom(address token) external override nonReentrant {\n\t\t_unstakeAllFrom(token);\n\t}\n\n\tfunction updateReward() external override nonReentrant {\n\t\t_updateRewardFor(_msgSender());\n\t}\n\n\tfunction updateRewardFor(address account) external override nonReentrant {\n\t\t_updateRewardFor(account);\n\t}\n\n\tfunction updateTokenRewards() external override nonReentrant {\n\t\t_updateRewards();\n\t}\n\n\t/* Public Views */\n\n\tfunction accruedRewardsPerTokenFor(address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _getAccruedRewardsPerTokenFor(token, totalRewardsAccruedFor(token));\n\t}\n\n\tfunction accruedRewardsPerTokenPaidFor(address account, address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _users[account].rewards[token].accruedPerTokenPaid;\n\t}\n\n\tfunction stakedBalanceOfFor(address account, address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tEnumerableMap.AddressToUintMap storage staked = _users[account].staked;\n\t\tif (staked.contains(token)) {\n\t\t\treturn staked.get(token);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tfunction totalRewardsAccrued() public view override returns (uint256) {\n\t\t// Overflow is OK\n\t\treturn _currentRewardsBalance() + _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsAccruedFor(address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tTokenData storage td = _tokenData[token];\n\t\t// Overflow is OK\n\t\treturn td.rewards + td.rewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemed() public view override returns (uint256) {\n\t\treturn _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemedFor(address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].rewardsRedeemed;\n\t}\n\n\tfunction totalStakedFor(address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _tokenData[token].totalStaked;\n\t}\n\n\tfunction valuePerTokenImplFor(address token)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _tokenData[token].valueImpl;\n\t}\n\n\t/* Internal Views */\n\n\tfunction _currentRewardsBalance() internal view virtual returns (uint256) {\n\t\treturn IERC20(rewardsToken).balanceOf(address(this));\n\t}\n\n\tfunction _getAccruedRewardsPerTokenFor(\n\t\taddress token,\n\t\tuint256 totalRewardsAccruedForToken\n\t) internal view virtual returns (uint256) {\n\t\tTokenData storage td = _tokenData[token];\n\t\tif (td.totalStaked == 0) {\n\t\t\treturn td.accruedRewardsPerToken;\n\t\t}\n\n\t\t// Overflow is OK: delta is correct anyway\n\t\tuint256 delta = totalRewardsAccruedForToken - td.lastRewardsAccrued;\n\t\tif (delta == 0) {\n\t\t\treturn td.accruedRewardsPerToken;\n\t\t}\n\n\t\t// Usemultiplier for better rounding\n\t\tuint256 rewardsPerToken = delta.mul(_MULTIPLIER).div(td.totalStaked);\n\n\t\t// Overflow is OK\n\t\treturn td.accruedRewardsPerToken + rewardsPerToken;\n\t}\n\n\tfunction _pendingRewardsOfFor(\n\t\taddress account,\n\t\taddress token,\n\t\tuint256 accruedRewardsPerToken\n\t) internal view virtual returns (uint256) {\n\t\tuint256 arptPaid = accruedRewardsPerTokenPaidFor(account, token);\n\t\t// Overflow is OK: delta is correct anyway\n\t\tuint256 accruedDelta = accruedRewardsPerToken - arptPaid;\n\n\t\t// Divide by _MULTIPLIER to convert back to rewards decimals\n\t\treturn\n\t\t\tstakedBalanceOfFor(account, token).mul(accruedDelta).div(_MULTIPLIER);\n\t}\n\n\t/**\n\t * We base the number of shares you receive on the number of ETHtx that are\n\t * staked to the token contract. A market maker could consider trying to game\n\t * this by depositing a lot of ETHtx and very little WETH, but they would\n\t * end up losing more money than they would gain from rewards because the\n\t * market would naturally take advantage of this arbitrage between the\n\t * weiWard contract price and the LP price.\n\t */\n\tfunction _shares(address token, uint256 amountStaked)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tIValuePerToken vptHandle = IValuePerToken(valuePerTokenImplFor(token));\n\t\t(uint256 numerator, uint256 denominator) = vptHandle.valuePerToken();\n\t\tif (denominator == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t// TODO handle fractional (i.e. improve rounding)\n\t\t// Return a 1:1 ratio for value to shares\n\t\treturn amountStaked.mul(numerator).div(denominator);\n\t}\n\n\tfunction _totalShares() internal view returns (uint256 total) {\n\t\t// WARNING: Be careful adding too many tokens.\n\t\tfor (uint256 i = 0; i < _tokens.length(); i++) {\n\t\t\ttotal = total.add(_totalSharesFor(_tokens.at(i)));\n\t\t}\n\t}\n\n\tfunction _totalSharesFor(address token) internal view returns (uint256) {\n\t\treturn _shares(token, _tokenData[token].totalStaked);\n\t}\n\n\t/* Internal Mutators */\n\n\t/**\n\t * WARNING: Avoid adding too many tokens to save on gas.\n\t * See {LPRewardsAuto-_updateRewards} for explanation.\n\t */\n\tfunction _addToken(address token, address tokenValueImpl) internal {\n\t\trequire(!_tokens.contains(token), \"LPRewardsAuto: token already added\");\n\t\trequire(\n\t\t\ttokenValueImpl != address(0),\n\t\t\t\"LPRewardsAuto: tokenValueImpl cannot be zero address\"\n\t\t);\n\t\t_updateRewards();\n\t\t_tokens.add(token);\n\t\t// Only update implementation in case this was previously used\n\t\t_tokenData[token].valueImpl = tokenValueImpl;\n\t\temit TokenAdded(token, tokenValueImpl);\n\t}\n\n\tfunction _changeTokenValueImpl(address token, address tokenValueImpl)\n\t\tinternal\n\t{\n\t\trequire(\n\t\t\t_tokens.contains(token),\n\t\t\t\"LPRewardsAuto: token has not been added\"\n\t\t);\n\t\trequire(\n\t\t\ttokenValueImpl != address(0),\n\t\t\t\"LPRewardsAuto: tokenValueImpl cannot be zero address\"\n\t\t);\n\t\t_updateRewards();\n\t\t_tokenData[token].valueImpl = tokenValueImpl;\n\t\temit TokenValueImplChanged(token, tokenValueImpl);\n\t}\n\n\tfunction _exit() internal virtual {\n\t\t// TODO perform simultaneously to optimize\n\t\t_unstakeAll();\n\t\t_redeemAllRewards();\n\t}\n\n\tfunction _exitFrom(address token) internal virtual {\n\t\t// TODO perform simultaneously to optimize\n\t\t_unstakeAllFrom(token);\n\t\t_redeemAllRewardsFrom(token);\n\t}\n\n\tfunction _recoverUnstaked(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal {\n\t\tuint256 unstaked =\n\t\t\tIERC20(token).balanceOf(address(this)).sub(\n\t\t\t\t_tokenData[token].totalStaked\n\t\t\t);\n\n\t\trequire(\n\t\t\tamount <= unstaked,\n\t\t\t\"LPRewardsAuto: cannot recover more tokens than are not staked\"\n\t\t);\n\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit RecoveredUnstaked(token, to, amount);\n\t}\n\n\tfunction _redeemAllRewards() internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\tuint256 amount = _users[account].totalRewards;\n\t\t_redeemRewardImpl(account, amount);\n\t}\n\n\tfunction _redeemAllRewardsFrom(address token) internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\tuint256 amount = _users[account].rewards[token].pending;\n\t\t_redeemRewardFromImpl(account, token, amount);\n\t}\n\n\tfunction _redeemReward(uint256 amount) internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\tuint256 reward = _users[account].totalRewards;\n\t\trequire(\n\t\t\tamount <= reward,\n\t\t\t\"LPRewardsAuto: cannot redeem more rewards than you have earned\"\n\t\t);\n\t\t_redeemRewardImpl(account, amount);\n\t}\n\n\tfunction _redeemRewardFrom(address token, uint256 amount) internal virtual {\n\t\taddress account = _msgSender();\n\t\t_updateRewardFor(account);\n\t\tuint256 reward = _users[account].rewards[token].pending;\n\t\trequire(\n\t\t\tamount <= reward,\n\t\t\t\"LPRewardsAuto: cannot redeem more rewards than you have earned\"\n\t\t);\n\t\t_redeemRewardFromImpl(account, token, amount);\n\t}\n\n\tfunction _redeemRewardImpl(address account, uint256 amount)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tuint256 amountLeft = amount;\n\t\tUserData storage user = _users[account];\n\t\t// WARNING: Be careful adding too many tokens.\n\t\tuint256 i = 0;\n\t\tuint256 length = user.tokensWithRewards.length();\n\t\twhile (i < length) {\n\t\t\taddress token = user.tokensWithRewards.at(i);\n\n\t\t\tUserTokenRewards storage rewards = user.rewards[token];\n\t\t\tif (rewards.pending == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTokenData storage td = _tokenData[token];\n\n\t\t\tuint256 taken = Math.min(rewards.pending, amountLeft);\n\n\t\t\t// Update loop params\n\t\t\tif (taken == rewards.pending && !user.staked.contains(token)) {\n\t\t\t\t// Remove from Set since no more rewards can be accrued.\n\t\t\t\tuser.tokensWithRewards.remove(token);\n\t\t\t\tlength--;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Update values\n\t\t\trewards.pending -= taken;\n\t\t\trewards.redeemed += taken;\n\n\t\t\ttd.rewards = td.rewards.sub(taken);\n\t\t\ttd.rewardsRedeemed += taken;\n\n\t\t\tamountLeft -= taken;\n\n\t\t\tif (amountLeft == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trequire(amountLeft == 0, \"LPRewardsAuto: failed to redeem enough rewards\");\n\n\t\tuser.totalRewards = user.totalRewards.sub(amount);\n\t\tuser.totalRedeemed += amount;\n\t\t_totalRewardsRedeemed += amount;\n\n\t\t_transferRewards(account, amount);\n\t\temit RewardPaid(account, amount);\n\t}\n\n\tfunction _redeemRewardFromImpl(\n\t\taddress account,\n\t\taddress token,\n\t\tuint256 amount\n\t) internal virtual {\n\t\t// Exit on zero, especially to protect from addresses without a history\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tTokenData storage td = _tokenData[token];\n\t\tUserData storage user = _users[account];\n\t\tUserTokenRewards storage rewards = user.rewards[token];\n\n\t\trewards.pending = rewards.pending.sub(amount);\n\t\trewards.redeemed += amount;\n\n\t\tuser.totalRewards = user.totalRewards.sub(amount);\n\t\tuser.totalRedeemed += amount;\n\n\t\ttd.rewards = td.rewards.sub(amount);\n\t\ttd.rewardsRedeemed += amount;\n\n\t\t_totalRewardsRedeemed += amount;\n\n\t\t_transferRewards(account, amount);\n\t\temit RewardPaid(account, amount);\n\t}\n\n\tfunction _removeToken(address token) internal {\n\t\trequire(\n\t\t\t_tokens.contains(token),\n\t\t\t\"LPRewardsAuto: token has not been added\"\n\t\t);\n\t\t_updateRewards();\n\t\t_tokens.remove(token);\n\t\t// Clean up. Keep totalStaked and rewards since those will be cleaned up by\n\t\t// users unstaking and redeeming\n\t\t_tokenData[token].valueImpl = address(0);\n\t\temit TokenRemoved(token);\n\t}\n\n\tfunction _stake(address token, uint256 amount) internal virtual {\n\t\trequire(amount > 0, \"LPRewardsAuto: cannot stake zero\");\n\t\trequire(_tokens.contains(token), \"LPRewardsAuto: token not supported\");\n\n\t\taddress account = _msgSender();\n\n\t\t// Prevent spending gas without having a balance\n\t\tuint256 balance = IERC20(token).balanceOf(account);\n\t\trequire(\n\t\t\tamount <= balance,\n\t\t\t\"LPRewardsAuto: cannot stake more than balance\"\n\t\t);\n\n\t\t// Prevent spending gas without having an allowance\n\t\tuint256 allowance = IERC20(token).allowance(account, address(this));\n\t\trequire(\n\t\t\tamount <= allowance,\n\t\t\t\"LPRewardsAuto: cannot stake more than allowance\"\n\t\t);\n\n\t\tUserData storage user = _users[account];\n\n\t\t_updateRewardOfFor(account, token);\n\t\tuser.tokensWithRewards.add(token);\n\n\t\tTokenData storage td = _tokenData[token];\n\t\ttd.totalStaked = td.totalStaked.add(amount);\n\n\t\tuint256 totalStaked = amount;\n\t\tif (user.staked.contains(token)) {\n\t\t\ttotalStaked = totalStaked.add(stakedBalanceOfFor(account, token));\n\t\t}\n\t\tuser.staked.set(token, totalStaked);\n\n\t\tIERC20(token).safeTransferFrom(account, address(this), amount);\n\t\temit Staked(account, amount);\n\t}\n\n\tfunction _transferRewards(address account, uint256 amount) internal virtual {\n\t\tIERC20(rewardsToken).safeTransfer(account, amount);\n\t}\n\n\tfunction _unstake(address token, uint256 amount) internal virtual {\n\t\trequire(amount > 0, \"LPRewardsAuto: cannot unstake zero\");\n\n\t\taddress account = _msgSender();\n\t\t// This prevents making calls to any addresses that were never supported.\n\t\tuint256 staked = stakedBalanceOfFor(account, token);\n\t\trequire(\n\t\t\tamount <= staked,\n\t\t\t\"LPRewardsAuto: cannot unstake more than staked balance\"\n\t\t);\n\n\t\t_updateRewardOfFor(account, token);\n\n\t\tTokenData storage td = _tokenData[token];\n\t\ttd.totalStaked = td.totalStaked.sub(amount);\n\n\t\tUserData storage user = _users[account];\n\t\tuint256 stakeLeft = staked.sub(amount);\n\t\tif (stakeLeft == 0) {\n\t\t\tuser.staked.remove(token);\n\t\t\tif (user.rewards[token].pending == 0) {\n\t\t\t\tuser.tokensWithRewards.remove(token);\n\t\t\t}\n\t\t} else {\n\t\t\tuser.staked.set(token, stakeLeft);\n\t\t}\n\n\t\tIERC20(token).safeTransfer(account, amount);\n\t\temit Unstaked(account, amount);\n\t}\n\n\tfunction _unstakeAll() internal virtual {\n\t\tUserData storage user = _users[_msgSender()];\n\t\t// WARNING: Be careful adding too many tokens.\n\t\tfor (uint256 length = user.staked.length(); length > 0; length--) {\n\t\t\t(address token, uint256 amount) = user.staked.at(0);\n\t\t\t_unstake(token, amount);\n\t\t}\n\t}\n\n\tfunction _unstakeAllFrom(address token) internal virtual {\n\t\t_unstake(token, stakedBalanceOfFor(_msgSender(), token));\n\t}\n\n\tfunction _updateAccrualFor(address token) internal {\n\t\tuint256 rewardsAccrued = totalRewardsAccruedFor(token);\n\t\tTokenData storage td = _tokenData[token];\n\t\ttd.accruedRewardsPerToken = _getAccruedRewardsPerTokenFor(\n\t\t\ttoken,\n\t\t\trewardsAccrued\n\t\t);\n\t\ttd.lastRewardsAccrued = rewardsAccrued;\n\t}\n\n\tfunction _updateRewardFor(address account) internal {\n\t\t_updateRewards();\n\n\t\tUserData storage user = _users[account];\n\t\tuint256 totalRewards = user.totalRewards;\n\n\t\tfor (uint256 i = 0; i < user.staked.length(); i++) {\n\t\t\t(address token, ) = user.staked.at(i);\n\t\t\tuint256 pending = _updateRewardOfForImpl(account, token);\n\t\t\ttotalRewards = totalRewards.add(pending);\n\t\t}\n\n\t\tuser.totalRewards = totalRewards;\n\t}\n\n\tfunction _updateRewardOfFor(address account, address token) internal {\n\t\t_updateRewards();\n\t\tuint256 pending = _updateRewardOfForImpl(account, token);\n\t\tUserData storage user = _users[account];\n\t\tuser.totalRewards = user.totalRewards.add(pending);\n\t}\n\n\tfunction _updateRewardOfForImpl(address account, address token)\n\t\tinternal\n\t\treturns (uint256 pending)\n\t{\n\t\t_updateAccrualFor(token);\n\n\t\t// updateAccrual updates accruedRewardsPerToken\n\t\tuint256 arpt = _tokenData[token].accruedRewardsPerToken;\n\t\tpending = _pendingRewardsOfFor(account, token, arpt);\n\n\t\t// Update values\n\t\tUserTokenRewards storage rewards = _users[account].rewards[token];\n\t\trewards.accruedPerTokenPaid = arpt;\n\t\trewards.pending = rewards.pending.add(pending);\n\t}\n\n\t/**\n\t * We have to allocate rewards all at once because shares can change over\n\t * time without interacting with this contract.\n\t * As such, avoid adding too many tokens to save on gas.\n\t * E.G. When working with multiple liquidity pools on different DEXs,\n\t * shares per token will change with price.\n\t */\n\tfunction _updateRewards() internal {\n\t\t// Get current pending rewards.\n\t\tuint256 _totalRewardsAccrued = totalRewardsAccrued();\n\t\tuint256 pending = _totalRewardsAccrued - _lastTotalRewardsAccrued;\n\t\t// Update last before iterating, just in case.\n\t\t_lastTotalRewardsAccrued = _totalRewardsAccrued;\n\n\t\t// Iterate once to know totalShares.\n\t\tuint256 totalShares = 0;\n\t\t// Store some math for current shares to save on gas and revert ASAP.\n\t\tuint256[] memory pendingSharesFor = new uint256[](_tokens.length());\n\t\tfor (uint256 i = 0; i < _tokens.length(); i++) {\n\t\t\tuint256 share = _totalSharesFor(_tokens.at(i));\n\t\t\tpendingSharesFor[i] = pending.mul(share);\n\t\t\ttotalShares = totalShares.add(share);\n\t\t}\n\n\t\tif (totalShares == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Iterate twice to give rewards.\n\t\tfor (uint256 i = 0; i < _tokens.length(); i++) {\n\t\t\tuint256 reward = pendingSharesFor[i].div(totalShares);\n\t\t\tTokenData storage td = _tokenData[_tokens.at(i)];\n\t\t\ttd.rewards = td.rewards.add(reward);\n\t\t}\n\n\t\t// Don't need to store last values and interpolate because:\n\t\t// If we assume all dex's prices are equal (a false assumption but perhaps a safe one), their reserves should move up and down together; thus, they maintain relative share value. Then we can update rewards without extrapolating what the shares might have been over time. If it's problematic, we can manually call this update on a regular interval. The same would be true if dex prices relative to each other were swinging violently anyway - extrapolation wouldn't work. Besides, this behaviour would incentivize the use of low volume DEXs, since they'd get more rewards than they should (low volume always means high price). Or we can just choose to remove a low volume dex.\n\t}\n}\n"
    },
    "contracts/rewards/interfaces/ILPRewardsAuto.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface ILPRewardsAuto {\n\t/* Views */\n\n\tfunction accruedRewardsPerTokenFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction accruedRewardsPerTokenPaidFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentAccruedRewardsPerTokenFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentRewardsBalanceOf(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentRewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentSharesFor(address token) external view returns (uint256);\n\n\tfunction currentSharesOf(address account) external view returns (uint256);\n\n\tfunction currentSharesOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentSharesPerTokenFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentTotalRewardsAccruedFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction currentTotalShares() external view returns (uint256);\n\n\tfunction numStakingTokens() external view returns (uint256);\n\n\tfunction rewardsBalanceOf(address account) external view returns (uint256);\n\n\tfunction rewardsBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction rewardsFor(address token) external view returns (uint256);\n\n\tfunction rewardsRedeemedBy(address account) external view returns (uint256);\n\n\tfunction rewardsRedeemedByFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction rewardsToken() external view returns (address);\n\n\tfunction stakedBalanceOfFor(address account, address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction stakingTokenAt(uint256 index) external view returns (address);\n\n\tfunction supportsStakingToken(address token) external view returns (bool);\n\n\tfunction totalRewardsAccrued() external view returns (uint256);\n\n\tfunction totalRewardsAccruedFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction totalRewardsRedeemed() external view returns (uint256);\n\n\tfunction totalRewardsRedeemedFor(address token)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction totalStakedFor(address token) external view returns (uint256);\n\n\tfunction valuePerTokenImplFor(address token) external view returns (address);\n\n\t/* Mutators */\n\n\tfunction addToken(address token, address tokenValueImpl) external;\n\n\tfunction changeTokenValueImpl(address token, address tokenValueImpl)\n\t\texternal;\n\n\tfunction exit() external;\n\n\tfunction exitFrom(address token) external;\n\n\tfunction pause() external;\n\n\tfunction recoverUnstaked(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction redeemAllRewards() external;\n\n\tfunction redeemAllRewardsFrom(address token) external;\n\n\tfunction redeemReward(uint256 amount) external;\n\n\tfunction redeemRewardFrom(address token, uint256 amount) external;\n\n\tfunction removeToken(address token) external;\n\n\tfunction stake(address token, uint256 amount) external;\n\n\tfunction unpause() external;\n\n\tfunction unstake(address token, uint256 amount) external;\n\n\tfunction unstakeAll() external;\n\n\tfunction unstakeAllFrom(address token) external;\n\n\tfunction updateReward() external;\n\n\tfunction updateRewardFor(address account) external;\n\n\tfunction updateTokenRewards() external;\n\n\t/* Events */\n\n\tevent RecoveredUnstaked(\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RewardPaid(address indexed account, uint256 amount);\n\tevent Staked(address indexed account, uint256 amount);\n\tevent Unstaked(address indexed account, uint256 amount);\n\tevent TokenAdded(address indexed token, address indexed tokenValueImpl);\n\tevent TokenRemoved(address indexed token);\n\tevent TokenValueImplChanged(\n\t\taddress indexed token,\n\t\taddress indexed tokenValueImpl\n\t);\n}\n"
    },
    "contracts/rewards/mocks/MockLPRewardsAuto.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../LPRewardsAuto.sol\";\n\ncontract MockLPRewardsAuto is LPRewardsAuto {\n\tconstructor(address _rewardsToken) LPRewardsAuto(_rewardsToken) {\n\t\treturn;\n\t}\n\n\tfunction multiplier() public pure returns (uint256) {\n\t\treturn _MULTIPLIER;\n\t}\n\n\tfunction setAccruedRewardsPerTokenFor(address token, uint256 value) public {\n\t\t_tokenData[token].accruedRewardsPerToken = value;\n\t}\n\n\tfunction setRewardsRedeemedFor(address token, uint256 value) public {\n\t\t_tokenData[token].rewardsRedeemed = value;\n\t}\n\n\tfunction setLastRewardsAccruedFor(address token, uint256 value) public {\n\t\t_tokenData[token].lastRewardsAccrued = value;\n\t}\n\n\tfunction setLastTotalRewardsAccrued(uint256 value) public {\n\t\t_lastTotalRewardsAccrued = value;\n\t}\n\n\tfunction setTotalRewardsRedeemed(uint256 value) public {\n\t\t_totalRewardsRedeemed = value;\n\t}\n}\n"
    },
    "contracts/rewards/FeeLogic.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./interfaces/IFeeLogic.sol\";\nimport \"../access/Ownable.sol\";\n\ncontract FeeLogic is Ownable, IFeeLogic {\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing SafeMath for uint128;\n\tusing SafeMath for uint256;\n\n\tstruct FeeLogicArgs {\n\t\taddress owner;\n\t\taddress recipient;\n\t\tuint128 feeRateNumerator;\n\t\tuint128 feeRateDenominator;\n\t\tExemptData[] exemptions;\n\t\tuint256 rebaseInterval;\n\t\tuint128 rebaseFeeRateNum;\n\t\tuint128 rebaseFeeRateDen;\n\t\tExemptData[] rebaseExemptions;\n\t}\n\n\t/* Mutable Private State */\n\n\tEnumerableSet.AddressSet private _exempts;\n\tuint128 private _feeRateNum;\n\tuint128 private _feeRateDen;\n\taddress private _recipient;\n\n\tEnumerableSet.AddressSet private _rebaseExempts;\n\tuint256 private _rebaseInterval;\n\tuint128 private _rebaseFeeRateNum;\n\tuint128 private _rebaseFeeRateDen;\n\n\t/* Constructor */\n\n\tconstructor(FeeLogicArgs memory _args) Ownable(_args.owner) {\n\t\trequire(\n\t\t\t_args.feeRateDenominator > _args.feeRateNumerator,\n\t\t\t\"FeeLogic: feeRate is gte to 1\"\n\t\t);\n\t\trequire(\n\t\t\t_args.rebaseFeeRateDen > _args.rebaseFeeRateNum,\n\t\t\t\"FeeLogic: rebaseFeeRate is gte to 1\"\n\t\t);\n\n\t\taddress sender = _msgSender();\n\n\t\t_recipient = _args.recipient;\n\t\temit RecipientSet(sender, _args.recipient);\n\t\t_feeRateNum = _args.feeRateNumerator;\n\t\t_feeRateDen = _args.feeRateDenominator;\n\t\temit FeeRateSet(sender, _args.feeRateNumerator, _args.feeRateDenominator);\n\n\t\tfor (uint256 i = 0; i < _args.exemptions.length; i++) {\n\t\t\taddress account = _args.exemptions[i].account;\n\t\t\tif (_args.exemptions[i].isExempt) {\n\t\t\t\tif (_exempts.add(account)) {\n\t\t\t\t\temit ExemptAdded(sender, account);\n\t\t\t\t}\n\t\t\t} else if (_exempts.remove(account)) {\n\t\t\t\temit ExemptRemoved(sender, account);\n\t\t\t}\n\t\t}\n\n\t\t_rebaseInterval = _args.rebaseInterval;\n\t\temit RebaseIntervalSet(sender, _args.rebaseInterval);\n\n\t\t_rebaseFeeRateNum = _args.rebaseFeeRateNum;\n\t\t_rebaseFeeRateDen = _args.rebaseFeeRateDen;\n\t\temit RebaseFeeRateSet(\n\t\t\tsender,\n\t\t\t_args.rebaseFeeRateNum,\n\t\t\t_args.rebaseFeeRateDen\n\t\t);\n\n\t\tfor (uint256 i = 0; i < _args.rebaseExemptions.length; i++) {\n\t\t\taddress account = _args.rebaseExemptions[i].account;\n\t\t\tif (_args.rebaseExemptions[i].isExempt) {\n\t\t\t\tif (_rebaseExempts.add(account)) {\n\t\t\t\t\temit RebaseExemptAdded(sender, account);\n\t\t\t\t}\n\t\t\t} else if (_rebaseExempts.remove(account)) {\n\t\t\t\temit RebaseExemptRemoved(sender, account);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* External Views */\n\n\tfunction exemptsAt(uint256 index)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _exempts.at(index);\n\t}\n\n\tfunction exemptsLength() external view virtual override returns (uint256) {\n\t\treturn _exempts.length();\n\t}\n\n\tfunction feeRate()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint128 numerator, uint128 denominator)\n\t{\n\t\tnumerator = _feeRateNum;\n\t\tdenominator = _feeRateDen;\n\t}\n\n\tfunction getFee(\n\t\taddress sender,\n\t\taddress, /* recipient_ */\n\t\tuint256 amount\n\t) external view virtual override returns (uint256) {\n\t\tif (_exempts.contains(sender)) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn amount.mul(_feeRateNum) / _feeRateDen;\n\t}\n\n\tfunction getRebaseFee(uint256 amount)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn amount.mul(_rebaseFeeRateNum) / _rebaseFeeRateDen;\n\t}\n\n\tfunction isExempt(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _exempts.contains(account);\n\t}\n\n\tfunction isRebaseExempt(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _rebaseExempts.contains(account);\n\t}\n\n\tfunction rebaseExemptsAt(uint256 index)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _rebaseExempts.at(index);\n\t}\n\n\tfunction rebaseExemptsLength()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _rebaseExempts.length();\n\t}\n\n\tfunction rebaseFeeRate()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint128 numerator, uint128 denominator)\n\t{\n\t\tnumerator = _rebaseFeeRateNum;\n\t\tdenominator = _rebaseFeeRateDen;\n\t}\n\n\tfunction rebaseInterval() external view virtual override returns (uint256) {\n\t\treturn _rebaseInterval;\n\t}\n\n\tfunction recipient() external view virtual override returns (address) {\n\t\treturn _recipient;\n\t}\n\n\tfunction undoFee(\n\t\taddress sender,\n\t\taddress, /* recipient_ */\n\t\tuint256 amount\n\t) external view virtual override returns (uint256) {\n\t\tif (_exempts.contains(sender)) {\n\t\t\treturn amount;\n\t\t}\n\t\treturn amount.mul(_feeRateDen) / (_feeRateDen - _feeRateNum);\n\t}\n\n\tfunction undoRebaseFee(uint256 amount)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn\n\t\t\tamount.mul(_rebaseFeeRateDen) / (_rebaseFeeRateDen - _rebaseFeeRateNum);\n\t}\n\n\t/* External Mutators */\n\n\tfunction notify(\n\t\tuint256 /* amount */\n\t) external virtual override {\n\t\treturn;\n\t}\n\n\tfunction setExempt(address account, bool isExempt_)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\tif (isExempt_) {\n\t\t\tif (_exempts.add(account)) {\n\t\t\t\temit ExemptAdded(_msgSender(), account);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (_exempts.remove(account)) {\n\t\t\temit ExemptRemoved(_msgSender(), account);\n\t\t}\n\t}\n\n\tfunction setExemptBatch(ExemptData[] memory batch)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\tfor (uint256 i = 0; i < batch.length; i++) {\n\t\t\tsetExempt(batch[i].account, batch[i].isExempt);\n\t\t}\n\t}\n\n\tfunction setFeeRate(uint128 numerator, uint128 denominator)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t// Also guarantees that the denominator cannot be zero.\n\t\trequire(denominator > numerator, \"FeeLogic: feeRate is gte to 1\");\n\t\t_feeRateNum = numerator;\n\t\t_feeRateDen = denominator;\n\t\temit FeeRateSet(_msgSender(), numerator, denominator);\n\t}\n\n\tfunction setRebaseExempt(address account, bool isExempt_)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\tif (isExempt_) {\n\t\t\tif (_rebaseExempts.add(account)) {\n\t\t\t\temit RebaseExemptAdded(_msgSender(), account);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (_rebaseExempts.remove(account)) {\n\t\t\temit RebaseExemptRemoved(_msgSender(), account);\n\t\t}\n\t}\n\n\tfunction setRebaseExemptBatch(ExemptData[] memory batch)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\tfor (uint256 i = 0; i < batch.length; i++) {\n\t\t\tsetRebaseExempt(batch[i].account, batch[i].isExempt);\n\t\t}\n\t}\n\n\tfunction setRebaseFeeRate(uint128 numerator, uint128 denominator)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t// Also guarantees that the denominator cannot be zero.\n\t\trequire(denominator > numerator, \"FeeLogic: rebaseFeeRate is gte to 1\");\n\t\t_rebaseFeeRateNum = numerator;\n\t\t_rebaseFeeRateDen = denominator;\n\t\temit RebaseFeeRateSet(_msgSender(), numerator, denominator);\n\t}\n\n\tfunction setRebaseInterval(uint256 interval)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_rebaseInterval = interval;\n\t\temit RebaseIntervalSet(_msgSender(), interval);\n\t}\n\n\tfunction setRecipient(address account) external virtual override onlyOwner {\n\t\trequire(account != address(0), \"FeeLogic: recipient is zero address\");\n\t\t_recipient = account;\n\t\temit RecipientSet(_msgSender(), account);\n\t}\n}\n"
    },
    "contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Based on https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.3.0-solc-0.7/contracts/access/Ownable.sol\n *\n * Changes:\n * - Added owner argument to constructor\n * - Reformatted styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n\taddress private _owner;\n\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor(address owner_) {\n\t\t_owner = owner_;\n\t\temit OwnershipTransferred(address(0), owner_);\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\temit OwnershipTransferred(_owner, address(0));\n\t\t_owner = address(0);\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\temit OwnershipTransferred(_owner, newOwner);\n\t\t_owner = newOwner;\n\t}\n}\n"
    },
    "contracts/rewards/mocks/MockFeeLogic.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../FeeLogic.sol\";\n\ncontract MockFeeLogic is FeeLogic {\n\tevent Notified(uint256 amount);\n\n\tconstructor(FeeLogic.FeeLogicArgs memory _args) FeeLogic(_args) {\n\t\treturn;\n\t}\n\n\tfunction notify(uint256 amount) external override {\n\t\temit Notified(amount);\n\t}\n}\n"
    },
    "contracts/rewards/RewardsManager/RewardsManagerData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\nabstract contract RewardsManagerData {\n\tstruct Shares {\n\t\tuint128 active;\n\t\tuint128 total;\n\t}\n\n\taddress internal _rewardsToken;\n\taddress internal _defaultRecipient;\n\tuint256 internal _totalRewardsRedeemed;\n\tEnumerableSet.AddressSet internal _recipients;\n\tmapping(address => Shares) internal _shares;\n\n\tuint256[45] private __gap;\n}\n"
    },
    "contracts/rewards/RewardsManager/RewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/SafeCast.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./RewardsManagerData.sol\";\nimport \"../interfaces/IRewardsManager.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\n\ncontract RewardsManager is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tRewardsManagerData,\n\tIRewardsManager\n{\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing SafeCast for uint256;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\tusing SafeMath for uint128;\n\n\tstruct RewardsManagerArgs {\n\t\taddress defaultRecipient;\n\t\taddress rewardsToken;\n\t\tShareData[] shares;\n\t}\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializers */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t}\n\n\tfunction postInit(RewardsManagerArgs memory _args)\n\t\texternal\n\t\tvirtual\n\t\tonlyOwner\n\t{\n\t\taddress sender = _msgSender();\n\n\t\t_rewardsToken = _args.rewardsToken;\n\t\temit RewardsTokenSet(sender, _args.rewardsToken);\n\n\t\tsetDefaultRecipient(_args.defaultRecipient);\n\n\t\tsetSharesBatch(_args.shares);\n\t}\n\n\t/* External Views */\n\n\tfunction defaultRecipient()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _defaultRecipient;\n\t}\n\n\tfunction rewardsToken() public view virtual override returns (address) {\n\t\treturn _rewardsToken;\n\t}\n\n\tfunction sharesFor(address account)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint128 active, uint128 total)\n\t{\n\t\tShares storage s = _shares[account];\n\t\treturn (s.active, s.total);\n\t}\n\n\tfunction totalRewardsAccrued()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\t// Overflow is OK\n\t\treturn _currentRewardsBalance() + _totalRewardsRedeemed;\n\t}\n\n\tfunction totalRewardsRedeemed()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _totalRewardsRedeemed;\n\t}\n\n\tfunction totalShares() public view virtual override returns (uint256 total) {\n\t\tfor (uint256 i = 0; i < _recipients.length(); i++) {\n\t\t\ttotal += _shares[_recipients.at(i)].total;\n\t\t}\n\t}\n\n\t/* External Mutators */\n\n\tfunction activateShares() external virtual override {\n\t\t_activate(_msgSender());\n\t}\n\n\tfunction activateSharesFor(address account)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_activate(account);\n\t}\n\n\tfunction addShares(address account, uint128 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsManager: cannot add shares to zero address\"\n\t\t);\n\t\trequire(\n\t\t\taccount != address(this),\n\t\t\t\"RewardsManager: cannot add shares to this contract address\"\n\t\t);\n\t\trequire(amount != 0, \"RewardsManager: cannot add zero shares\");\n\n\t\tShares storage s = _shares[account];\n\t\tif (s.active == 0) {\n\t\t\t// Add to inactive value\n\t\t\tShares storage d = _shares[_defaultRecipient];\n\t\t\td.active = d.active.add(amount).toUint128();\n\t\t} else {\n\t\t\ts.active = s.active.add(amount).toUint128();\n\t\t}\n\t\ts.total = s.total.add(amount).toUint128();\n\t\t_recipients.add(account);\n\t\temit SharesAdded(_msgSender(), account, amount);\n\t}\n\n\tfunction deactivateShares() external virtual override {\n\t\t_deactivate(_msgSender());\n\t}\n\n\tfunction deactivateSharesFor(address account)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_deactivate(account);\n\t}\n\n\tfunction recoverUnsupportedERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyOwner {\n\t\trequire(\n\t\t\ttoken != _rewardsToken,\n\t\t\t\"RewardsManager: cannot recover rewards token\"\n\t\t);\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit RecoveredUnsupported(_msgSender(), token, to, amount);\n\t}\n\n\tfunction removeShares(address account, uint128 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(amount != 0, \"RewardsManager: cannot remove zero shares\");\n\n\t\tShares storage s = _shares[account];\n\t\tif (s.active == 0) {\n\t\t\t// Remove from inactive value\n\t\t\tShares storage d = _shares[_defaultRecipient];\n\t\t\td.active = d.active.sub(amount).toUint128();\n\t\t} else {\n\t\t\ts.active = s.active.sub(amount).toUint128();\n\t\t}\n\t\ts.total = s.total.sub(amount).toUint128();\n\t\tif (s.total == 0) {\n\t\t\t_recipients.remove(account);\n\t\t}\n\t\temit SharesRemoved(_msgSender(), account, amount);\n\t}\n\n\tfunction setDefaultRecipient(address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsManager: cannot set to zero address\"\n\t\t);\n\t\trequire(\n\t\t\taccount != address(this),\n\t\t\t\"RewardsManager: cannot set to this contract\"\n\t\t);\n\n\t\t// Activate\n\t\t_activate(account);\n\n\t\t// Move any inactive shares\n\t\tShares storage original = _shares[_defaultRecipient];\n\t\tif (original.active > original.total) {\n\t\t\tuint128 inactive = original.active - original.total;\n\t\t\toriginal.active -= inactive;\n\n\t\t\tShares storage next = _shares[account];\n\t\t\tnext.active = next.active.add(inactive).toUint128();\n\t\t}\n\n\t\tif (original.total == 0) {\n\t\t\t_recipients.remove(_defaultRecipient);\n\t\t}\n\t\t_defaultRecipient = account;\n\t\t_recipients.add(account);\n\t\temit DefaultRecipientSet(_msgSender(), account);\n\t}\n\n\tfunction setRewardsToken(address token) public virtual override onlyOwner {\n\t\t_rewardsToken = token;\n\t\temit RewardsTokenSet(_msgSender(), token);\n\t}\n\n\tfunction setShares(\n\t\taddress account,\n\t\tuint128 value,\n\t\tbool isActive\n\t) public virtual override onlyOwner {\n\t\trequire(\n\t\t\taccount != address(0),\n\t\t\t\"RewardsManager: cannot set shares for zero address\"\n\t\t);\n\t\trequire(\n\t\t\taccount != address(this),\n\t\t\t\"RewardsManager: cannot set shares for this contract address\"\n\t\t);\n\n\t\t// Gas savings\n\t\taddress defaultRecipient_ = _defaultRecipient;\n\t\tShares storage d = _shares[defaultRecipient_];\n\n\t\tif (account == defaultRecipient_) {\n\t\t\td.active = d.active.sub(d.total).add(value).toUint128();\n\t\t\td.total = value;\n\t\t\temit SharesSet(_msgSender(), account, value, isActive);\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage s = _shares[account];\n\n\t\tif (s.total != 0 && s.active == 0) {\n\t\t\t// Subtract old inactive value\n\t\t\td.active = d.active.sub(s.total).toUint128();\n\t\t}\n\n\t\tif (!isActive) {\n\t\t\ts.active = 0;\n\t\t\t// Add new inactive value\n\t\t\td.active = d.active.add(value).toUint128();\n\t\t} else {\n\t\t\ts.active = value;\n\t\t}\n\n\t\ts.total = value;\n\t\tif (value != 0) {\n\t\t\t_recipients.add(account);\n\t\t} else {\n\t\t\t_recipients.remove(account);\n\t\t}\n\t\temit SharesSet(_msgSender(), account, value, isActive);\n\t}\n\n\tfunction setSharesBatch(ShareData[] memory batch)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\tfor (uint256 i = 0; i < batch.length; i++) {\n\t\t\tsetShares(batch[i].account, batch[i].value, batch[i].isActive);\n\t\t}\n\t}\n\n\t/* Internal Views */\n\n\tfunction _currentRewardsBalance() internal view virtual returns (uint256) {\n\t\treturn IERC20(_rewardsToken).balanceOf(address(this));\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _activate(address account) internal virtual {\n\t\tShares storage s = _shares[account];\n\n\t\t// Do nothing if already active\n\t\tif (s.total == 0 || s.active > 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage d = _shares[_defaultRecipient];\n\n\t\ts.active = s.total;\n\t\td.active = d.active.sub(s.total).toUint128();\n\t\temit SharesActivated(_msgSender(), account);\n\t}\n\n\tfunction _deactivate(address account) internal virtual {\n\t\t// Skip for the default recipient\n\t\tif (account == _defaultRecipient) {\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage s = _shares[account];\n\n\t\t// Do nothing if already deactivated\n\t\tif (s.active == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tShares storage d = _shares[_defaultRecipient];\n\n\t\ts.active = 0;\n\t\td.active = d.active.add(s.total).toUint128();\n\t\temit SharesDeactivated(_msgSender(), account);\n\t}\n}\n"
    },
    "contracts/rewards/interfaces/IRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IRewardsManager {\n\t/* Types */\n\n\tstruct ShareData {\n\t\taddress account;\n\t\tuint128 value;\n\t\tbool isActive;\n\t}\n\n\t/* Views */\n\n\tfunction defaultRecipient() external view returns (address);\n\n\tfunction rewardsToken() external view returns (address);\n\n\tfunction sharesFor(address account)\n\t\texternal\n\t\tview\n\t\treturns (uint128 active, uint128 total);\n\n\tfunction totalRewardsAccrued() external view returns (uint256);\n\n\tfunction totalRewardsRedeemed() external view returns (uint256);\n\n\tfunction totalShares() external view returns (uint256);\n\n\t/* Mutators */\n\n\tfunction activateShares() external;\n\n\tfunction activateSharesFor(address account) external;\n\n\tfunction addShares(address account, uint128 amount) external;\n\n\tfunction deactivateShares() external;\n\n\tfunction deactivateSharesFor(address account) external;\n\n\tfunction recoverUnsupportedERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction removeShares(address account, uint128 amount) external;\n\n\tfunction setDefaultRecipient(address account) external;\n\n\tfunction setRewardsToken(address token) external;\n\n\tfunction setShares(\n\t\taddress account,\n\t\tuint128 value,\n\t\tbool isActive\n\t) external;\n\n\tfunction setSharesBatch(ShareData[] memory batch) external;\n\n\t/* Events */\n\n\tevent DefaultRecipientSet(address indexed author, address indexed account);\n\tevent RecoveredUnsupported(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent RewardsTokenSet(address indexed author, address indexed token);\n\tevent SharesActivated(address indexed author, address indexed account);\n\tevent SharesAdded(\n\t\taddress indexed author,\n\t\taddress indexed account,\n\t\tuint128 amount\n\t);\n\tevent SharesDeactivated(address indexed author, address indexed account);\n\tevent SharesRemoved(\n\t\taddress indexed author,\n\t\taddress indexed account,\n\t\tuint128 amount\n\t);\n\tevent SharesSet(\n\t\taddress indexed author,\n\t\taddress indexed account,\n\t\tuint128 value,\n\t\tbool isActive\n\t);\n}\n"
    },
    "contracts/rewards/mocks/MockRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../RewardsManager/RewardsManager.sol\";\n\ncontract MockRewardsManager is RewardsManager {\n\tconstructor(address owner_) RewardsManager(owner_) {\n\t\treturn;\n\t}\n\n\tfunction setTotalRewardsRedeemed(uint256 value) external {\n\t\t_totalRewardsRedeemed = value;\n\t}\n}\n"
    },
    "contracts/rewards/ETHtxRewardsManager/ETHtxRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"./ETHtxRewardsManagerData.sol\";\nimport \"../../exchanges/interfaces/IETHtxAMM.sol\";\nimport \"../interfaces/IETHtxRewardsManager.sol\";\nimport \"../interfaces/IETHmxRewards.sol\";\nimport \"../interfaces/ILPRewards.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\nimport \"../RewardsManager/RewardsManager.sol\";\n\ncontract ETHtxRewardsManager is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tRewardsManager,\n\tETHtxRewardsManagerData,\n\tIETHtxRewardsManager\n{\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\n\tstruct ETHtxRewardsManagerArgs {\n\t\taddress defaultRecipient;\n\t\taddress rewardsToken;\n\t\taddress ethmxRewards;\n\t\taddress ethtx;\n\t\taddress ethtxAMM;\n\t\taddress lpRewards;\n\t\tShareData[] shares;\n\t}\n\n\t/* Constructor */\n\n\tconstructor(address owner_) RewardsManager(owner_) {\n\t\treturn;\n\t}\n\n\t/* Initializer */\n\n\t// init inherited from RewardsManager\n\n\tfunction ethtxRewardsManagerPostInit(ETHtxRewardsManagerArgs memory _args)\n\t\texternal\n\t\tvirtual\n\t\tonlyOwner\n\t{\n\t\taddress sender = _msgSender();\n\n\t\t_rewardsToken = _args.rewardsToken;\n\t\temit RewardsTokenSet(sender, _args.rewardsToken);\n\n\t\tsetDefaultRecipient(_args.defaultRecipient);\n\n\t\t_ethmxRewards = _args.ethmxRewards;\n\t\temit EthmxRewardsSet(sender, _args.ethmxRewards);\n\n\t\t_ethtx = _args.ethtx;\n\t\temit EthtxSet(sender, _args.ethtx);\n\n\t\t_ethtxAMM = _args.ethtxAMM;\n\t\temit EthtxAMMSet(sender, _args.ethtxAMM);\n\n\t\t_lpRewards = _args.lpRewards;\n\t\temit LPRewardsSet(sender, _args.lpRewards);\n\n\t\tsetSharesBatch(_args.shares);\n\t}\n\n\t/* External Mutators */\n\n\tfunction convertETHtx() public virtual override {\n\t\tIERC20 ethtxHandle = IERC20(ethtx());\n\t\tuint256 amount = ethtxHandle.balanceOf(address(this));\n\t\tif (amount == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\taddress ethtxAMM_ = ethtxAMM(); // Gas savings\n\t\tethtxHandle.safeIncreaseAllowance(ethtxAMM_, amount);\n\n\t\t// solhint-disable-next-line not-rely-on-time\n\t\tIETHtxAMM(ethtxAMM_).swapEthtxForEth(amount, block.timestamp, true);\n\t}\n\n\tfunction distributeRewards() external virtual override returns (uint256) {\n\t\tconvertETHtx();\n\t\tuint256 rewards = sendRewards();\n\t\tif (rewards != 0) {\n\t\t\tnotifyRecipients();\n\t\t}\n\t\treturn rewards;\n\t}\n\n\tfunction notifyRecipients() public virtual override {\n\t\t_notifyEthmxRewards();\n\t\t_notifyLpRewards();\n\t}\n\n\tfunction sendRewards() public virtual override returns (uint256) {\n\t\tuint256 rewards = _currentRewardsBalance();\n\t\tif (rewards == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 totalShares_ = totalShares();\n\n\t\tfor (uint256 i = 0; i < _recipients.length(); i++) {\n\t\t\t_sendTo(_recipients.at(i), totalShares_, rewards);\n\t\t}\n\n\t\t_totalRewardsRedeemed += rewards;\n\t\treturn rewards;\n\t}\n\n\tfunction setEthmxRewards(address account) public virtual override onlyOwner {\n\t\t_ethmxRewards = account;\n\t\temit EthmxRewardsSet(_msgSender(), account);\n\t}\n\n\tfunction setEthtx(address account) public virtual override onlyOwner {\n\t\t_ethtx = account;\n\t\temit EthtxSet(_msgSender(), account);\n\t}\n\n\tfunction setEthtxAMM(address account) public virtual override onlyOwner {\n\t\t_ethtxAMM = account;\n\t\temit EthtxAMMSet(_msgSender(), account);\n\t}\n\n\tfunction setLPRewards(address account) public virtual override onlyOwner {\n\t\t_lpRewards = account;\n\t\temit LPRewardsSet(_msgSender(), account);\n\t}\n\n\t/* Public Views */\n\n\tfunction ethmxRewards() public view virtual override returns (address) {\n\t\treturn _ethmxRewards;\n\t}\n\n\tfunction ethtx() public view virtual override returns (address) {\n\t\treturn _ethtx;\n\t}\n\n\tfunction ethtxAMM() public view virtual override returns (address) {\n\t\treturn _ethtxAMM;\n\t}\n\n\tfunction lpRewards() public view virtual override returns (address) {\n\t\treturn _lpRewards;\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _notifyEthmxRewards() internal virtual {\n\t\tIETHmxRewards ethmxRewardsHandle = IETHmxRewards(ethmxRewards());\n\t\tif (ethmxRewardsHandle.readyForUpdate()) {\n\t\t\tethmxRewardsHandle.updateAccrual();\n\t\t}\n\t}\n\n\tfunction _notifyLpRewards() internal virtual {\n\t\tILPRewards(lpRewards()).updateAccrual();\n\t}\n\n\tfunction _sendTo(\n\t\taddress account,\n\t\tuint256 totalShares_,\n\t\tuint256 totalRewards\n\t) internal virtual {\n\t\tShares storage s = _shares[account];\n\t\tuint256 amount = totalRewards.mul(s.active).div(totalShares_);\n\n\t\tIERC20(_rewardsToken).safeTransfer(account, amount);\n\t}\n}\n"
    },
    "contracts/rewards/ETHtxRewardsManager/ETHtxRewardsManagerData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract ETHtxRewardsManagerData {\n\taddress internal _ethmxRewards;\n\taddress internal _ethtx;\n\taddress internal _ethtxAMM;\n\taddress internal _lpRewards;\n\n\tuint256[46] private __gap;\n}\n"
    },
    "contracts/rewards/interfaces/IETHtxRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\ninterface IETHtxRewardsManager {\n\t/* Views */\n\n\tfunction ethmxRewards() external view returns (address);\n\n\tfunction ethtx() external view returns (address);\n\n\tfunction ethtxAMM() external view returns (address);\n\n\tfunction lpRewards() external view returns (address);\n\n\t/* Mutators */\n\n\tfunction convertETHtx() external;\n\n\tfunction distributeRewards() external returns (uint256);\n\n\tfunction notifyRecipients() external;\n\n\tfunction sendRewards() external returns (uint256);\n\n\tfunction setEthmxRewards(address account) external;\n\n\tfunction setEthtx(address account) external;\n\n\tfunction setEthtxAMM(address account) external;\n\n\tfunction setLPRewards(address account) external;\n\n\t/* Events */\n\n\tevent EthmxRewardsSet(address indexed author, address indexed account);\n\tevent EthtxSet(address indexed author, address indexed account);\n\tevent EthtxAMMSet(address indexed author, address indexed account);\n\tevent LPRewardsSet(address indexed author, address indexed account);\n\tevent RewardsSent(\n\t\taddress indexed author,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n}\n"
    },
    "contracts/rewards/mocks/MockETHtxRewardsManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../ETHtxRewardsManager/ETHtxRewardsManager.sol\";\n\ncontract MockETHtxRewardsManager is ETHtxRewardsManager {\n\tconstructor(address owner_) ETHtxRewardsManager(owner_) {\n\t\treturn;\n\t}\n\n\tfunction setTotalRewardsRedeemed(uint256 value) external {\n\t\t_totalRewardsRedeemed = value;\n\t}\n}\n"
    },
    "contracts/exchanges/ETHmxMinter/ETHmxMinter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\nimport \"./ETHmxMinterData.sol\";\nimport \"../../tokens/interfaces/IETHmx.sol\";\nimport \"../interfaces/IETHmxMinter.sol\";\nimport \"../../tokens/interfaces/IETHtx.sol\";\nimport \"../interfaces/IETHtxAMM.sol\";\nimport \"../../tokens/interfaces/IWETH.sol\";\nimport \"../../access/OwnableUpgradeable.sol\";\nimport \"../../libraries/UintLog.sol\";\n\n/* solhint-disable not-rely-on-time */\n\ninterface IPool {\n\tfunction addLiquidity(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tuint256 amountADesired,\n\t\tuint256 amountBDesired,\n\t\tuint256 amountAMin,\n\t\tuint256 amountBMin,\n\t\taddress to,\n\t\tuint256 deadline\n\t)\n\t\texternal\n\t\treturns (\n\t\t\tuint256 amountA,\n\t\t\tuint256 amountB,\n\t\t\tuint256 liquidity\n\t\t);\n}\n\ncontract ETHmxMinter is\n\tInitializable,\n\tContextUpgradeable,\n\tOwnableUpgradeable,\n\tPausableUpgradeable,\n\tETHmxMinterData,\n\tIETHmxMinter\n{\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\tusing SafeERC20 for IERC20;\n\tusing SafeMath for uint256;\n\tusing SafeMath for uint32;\n\tusing UintLog for uint256;\n\n\tstruct ETHmxMinterArgs {\n\t\taddress ethmx;\n\t\taddress ethtx;\n\t\taddress ethtxAMM;\n\t\taddress weth;\n\t\tETHmxMintParams ethmxMintParams;\n\t\tETHtxMintParams ethtxMintParams;\n\t\tuint128 lpShareNumerator;\n\t\tuint128 lpShareDenominator;\n\t\taddress[] lps;\n\t\taddress lpRecipient;\n\t}\n\n\tuint256 internal constant _GAS_PER_ETHTX = 21000; // per 1e18\n\tuint256 internal constant _GENESIS_START = 1620655200; // 05/10/2021 1400 UTC\n\tuint256 internal constant _GENESIS_END = 1621260000; // 05/17/2021 1400 UTC\n\tuint256 internal constant _GENESIS_AMOUNT = 3e21; // 3k ETH\n\n\t/* Constructor */\n\n\tconstructor(address owner_) {\n\t\tinit(owner_);\n\t}\n\n\t/* Initializer */\n\n\tfunction init(address owner_) public virtual initializer {\n\t\t__Context_init_unchained();\n\t\t__Ownable_init_unchained(owner_);\n\t\t__Pausable_init_unchained();\n\t}\n\n\tfunction postInit(ETHmxMinterArgs memory _args) external virtual onlyOwner {\n\t\taddress sender = _msgSender();\n\n\t\t_ethmx = _args.ethmx;\n\t\temit EthmxSet(sender, _args.ethmx);\n\n\t\t_ethtx = _args.ethtx;\n\t\temit EthtxSet(sender, _args.ethtx);\n\n\t\t_ethtxAMM = _args.ethtxAMM;\n\t\temit EthtxAMMSet(sender, _args.ethtxAMM);\n\n\t\t_weth = _args.weth;\n\t\temit WethSet(sender, _args.weth);\n\n\t\t_ethmxMintParams = _args.ethmxMintParams;\n\t\temit EthmxMintParamsSet(sender, _args.ethmxMintParams);\n\n\t\t_inGenesis = block.timestamp <= _GENESIS_END;\n\t\t_minMintPrice = _args.ethtxMintParams.minMintPrice;\n\t\t_mu = _args.ethtxMintParams.mu;\n\t\t_lambda = _args.ethtxMintParams.lambda;\n\t\temit EthtxMintParamsSet(sender, _args.ethtxMintParams);\n\n\t\t_lpShareNum = _args.lpShareNumerator;\n\t\t_lpShareDen = _args.lpShareDenominator;\n\t\temit LpShareSet(sender, _args.lpShareNumerator, _args.lpShareDenominator);\n\n\t\tfor (uint256 i = 0; i < _lps.length(); i++) {\n\t\t\taddress lp = _lps.at(i);\n\t\t\t_lps.remove(lp);\n\t\t\temit LpRemoved(sender, lp);\n\t\t}\n\t\tfor (uint256 i = 0; i < _args.lps.length; i++) {\n\t\t\taddress lp = _args.lps[i];\n\t\t\t_lps.add(lp);\n\t\t\temit LpAdded(sender, lp);\n\t\t}\n\n\t\t_lpRecipient = _args.lpRecipient;\n\t\temit LpRecipientSet(sender, _args.lpRecipient);\n\t}\n\n\tfunction addLp(address pool) external virtual override onlyOwner {\n\t\tbool added = _lps.add(pool);\n\t\trequire(added, \"ETHmxMinter: liquidity pool already added\");\n\t\temit LpAdded(_msgSender(), pool);\n\t}\n\n\tfunction mint() external payable virtual override whenNotPaused {\n\t\trequire(block.timestamp >= _GENESIS_START, \"ETHmxMinter: before genesis\");\n\t\tuint256 amountIn = msg.value;\n\t\trequire(amountIn != 0, \"ETHmxMinter: cannot mint with zero amount\");\n\n\t\t// Convert to WETH\n\t\taddress weth_ = weth();\n\t\tIWETH(weth_).deposit{ value: amountIn }();\n\n\t\t// Check if we're in genesis\n\t\tbool exitingGenesis;\n\t\tuint256 ethToMintEthtx = amountIn;\n\t\tif (_inGenesis) {\n\t\t\tuint256 totalGiven_ = _totalGiven.add(amountIn);\n\t\t\tif (block.timestamp >= _GENESIS_END || totalGiven_ >= _GENESIS_AMOUNT) {\n\t\t\t\t// Exiting genesis\n\t\t\t\tethToMintEthtx = totalGiven_;\n\t\t\t\texitingGenesis = true;\n\t\t\t} else {\n\t\t\t\tethToMintEthtx = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Mint ETHtx and send ETHtx-WETH pair.\n\t\t_mintEthtx(ethToMintEthtx);\n\n\t\t// Mint ETHmx to sender.\n\t\tuint256 amountOut = ethmxFromEth(amountIn);\n\t\t_mint(_msgSender(), amountOut);\n\t\t_totalGiven += amountIn;\n\t\t// WARN this could cause re-entrancy if we ever called an unkown address\n\t\tif (exitingGenesis) {\n\t\t\t_inGenesis = false;\n\t\t}\n\t}\n\n\tfunction mintWithETHtx(uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\twhenNotPaused\n\t{\n\t\trequire(amount != 0, \"ETHmxMinter: cannot mint with zero amount\");\n\n\t\tIETHtxAMM ammHandle = IETHtxAMM(ethtxAMM());\n\t\tuint256 amountETHIn = ammHandle.ethToExactEthtx(amount);\n\t\trequire(\n\t\t\tammHandle.ethNeeded() >= amountETHIn,\n\t\t\t\"ETHmxMinter: ETHtx value burnt exceeds ETH needed\"\n\t\t);\n\n\t\taddress account = _msgSender();\n\t\tIETHtx(ethtx()).burn(account, amount);\n\n\t\t_mint(account, amountETHIn);\n\t}\n\n\tfunction mintWithWETH(uint256 amount)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\twhenNotPaused\n\t{\n\t\trequire(block.timestamp >= _GENESIS_START, \"ETHmxMinter: before genesis\");\n\t\trequire(amount != 0, \"ETHmxMinter: cannot mint with zero amount\");\n\t\taddress account = _msgSender();\n\n\t\t// Need ownership for router\n\t\tIERC20(weth()).safeTransferFrom(account, address(this), amount);\n\n\t\t// Check if we're in genesis\n\t\tbool exitingGenesis;\n\t\tuint256 ethToMintEthtx = amount;\n\t\tif (_inGenesis) {\n\t\t\tuint256 totalGiven_ = _totalGiven.add(amount);\n\t\t\tif (block.timestamp >= _GENESIS_END || totalGiven_ >= _GENESIS_AMOUNT) {\n\t\t\t\t// Exiting genesis\n\t\t\t\tethToMintEthtx = totalGiven_;\n\t\t\t\texitingGenesis = true;\n\t\t\t} else {\n\t\t\t\tethToMintEthtx = 0;\n\t\t\t}\n\t\t}\n\n\t\t// Mint ETHtx and send ETHtx-WETH pair.\n\t\t_mintEthtx(ethToMintEthtx);\n\n\t\tuint256 amountOut = ethmxFromEth(amount);\n\t\t_mint(account, amountOut);\n\t\t_totalGiven += amount;\n\t\t// WARN this could cause re-entrancy if we ever called an unkown address\n\t\tif (exitingGenesis) {\n\t\t\t_inGenesis = false;\n\t\t}\n\t}\n\n\tfunction pause() external virtual override onlyOwner {\n\t\t_pause();\n\t}\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external virtual override onlyOwner {\n\t\trequire(token != _weth, \"ETHmxMinter: cannot recover WETH\");\n\t\tIERC20(token).safeTransfer(to, amount);\n\t\temit Recovered(_msgSender(), token, to, amount);\n\t}\n\n\tfunction removeLp(address pool) external virtual override onlyOwner {\n\t\tbool removed = _lps.remove(pool);\n\t\trequire(removed, \"ETHmxMinter: liquidity pool not present\");\n\t\temit LpRemoved(_msgSender(), pool);\n\t}\n\n\tfunction setEthmx(address addr) public virtual override onlyOwner {\n\t\t_ethmx = addr;\n\t\temit EthmxSet(_msgSender(), addr);\n\t}\n\n\tfunction setEthmxMintParams(ETHmxMintParams memory mp)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_ethmxMintParams = mp;\n\t\temit EthmxMintParamsSet(_msgSender(), mp);\n\t}\n\n\tfunction setEthtxMintParams(ETHtxMintParams memory mp)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_minMintPrice = mp.minMintPrice;\n\t\t_mu = mp.mu;\n\t\t_lambda = mp.lambda;\n\t\temit EthtxMintParamsSet(_msgSender(), mp);\n\t}\n\n\tfunction setEthtx(address addr) public virtual override onlyOwner {\n\t\t_ethtx = addr;\n\t\temit EthtxSet(_msgSender(), addr);\n\t}\n\n\tfunction setEthtxAMM(address addr) public virtual override onlyOwner {\n\t\t_ethtxAMM = addr;\n\t\temit EthtxAMMSet(_msgSender(), addr);\n\t}\n\n\tfunction setLpRecipient(address account)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t_lpRecipient = account;\n\t\temit LpRecipientSet(_msgSender(), account);\n\t}\n\n\tfunction setLpShare(uint128 numerator, uint128 denominator)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyOwner\n\t{\n\t\t// Also guarantees that the denominator cannot be zero.\n\t\trequire(denominator > numerator, \"ETHmxMinter: cannot set lpShare >= 1\");\n\t\t_lpShareNum = numerator;\n\t\t_lpShareDen = denominator;\n\t\temit LpShareSet(_msgSender(), numerator, denominator);\n\t}\n\n\tfunction setWeth(address addr) public virtual override onlyOwner {\n\t\t_weth = addr;\n\t\temit WethSet(_msgSender(), addr);\n\t}\n\n\tfunction unpause() external virtual override onlyOwner {\n\t\t_unpause();\n\t}\n\n\t/* Public Views */\n\n\tfunction ethmx() public view virtual override returns (address) {\n\t\treturn _ethmx;\n\t}\n\n\tfunction ethmxMintParams()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (ETHmxMintParams memory)\n\t{\n\t\treturn _ethmxMintParams;\n\t}\n\n\tfunction ethmxFromEth(uint256 amountETHIn)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tif (amountETHIn == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tETHmxMintParams memory mp = _ethmxMintParams;\n\t\tuint256 amountOut = _ethmxCurve(amountETHIn, mp);\n\n\t\tif (_inGenesis) {\n\t\t\tuint256 totalGiven_ = _totalGiven;\n\t\t\tuint256 totalEnd = totalGiven_.add(amountETHIn);\n\n\t\t\tif (totalEnd > _GENESIS_AMOUNT) {\n\t\t\t\t// Exiting genesis\n\t\t\t\tuint256 amtUnder = _GENESIS_AMOUNT - totalGiven_;\n\t\t\t\tamountOut -= amtUnder.mul(amountOut).div(amountETHIn);\n\t\t\t\tuint256 added =\n\t\t\t\t\tamtUnder.mul(2).mul(mp.zetaFloorNum).div(mp.zetaFloorDen);\n\t\t\t\treturn amountOut.add(added);\n\t\t\t}\n\n\t\t\treturn amountOut.mul(2);\n\t\t}\n\n\t\treturn amountOut;\n\t}\n\n\tfunction ethmxFromEthtx(uint256 amountETHtxIn)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn IETHtxAMM(ethtxAMM()).ethToExactEthtx(amountETHtxIn);\n\t}\n\n\tfunction ethtx() public view virtual override returns (address) {\n\t\treturn _ethtx;\n\t}\n\n\tfunction ethtxMintParams()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (ETHtxMintParams memory)\n\t{\n\t\treturn ETHtxMintParams(_minMintPrice, _mu, _lambda);\n\t}\n\n\tfunction ethtxAMM() public view virtual override returns (address) {\n\t\treturn _ethtxAMM;\n\t}\n\n\tfunction ethtxFromEth(uint256 amountETHIn)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\tif (amountETHIn == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tIETHtxAMM ammHandle = IETHtxAMM(_ethtxAMM);\n\t\t(uint256 collat, uint256 liability) = ammHandle.cRatio();\n\t\tuint256 gasPrice = ammHandle.gasPrice();\n\n\t\tuint256 basePrice;\n\t\tuint256 lambda_;\n\t\t{\n\t\t\tuint256 minMintPrice_ = _minMintPrice;\n\t\t\tuint256 mu_ = _mu;\n\t\t\tlambda_ = _lambda;\n\n\t\t\tbasePrice = mu_.mul(gasPrice).add(minMintPrice_);\n\t\t}\n\n\t\tif (liability == 0) {\n\t\t\t// If exiting genesis, flat 2x on minting price up to threshold\n\t\t\tif (_inGenesis) {\n\t\t\t\tuint256 totalGiven_ = _totalGiven;\n\t\t\t\tuint256 totalEnd = totalGiven_.add(amountETHIn);\n\n\t\t\t\tif (totalEnd > _GENESIS_AMOUNT) {\n\t\t\t\t\tuint256 amtOver = totalEnd - _GENESIS_AMOUNT;\n\t\t\t\t\tuint256 amtOut =\n\t\t\t\t\t\t_ethToEthtx(basePrice.mul(2), amountETHIn - amtOver);\n\t\t\t\t\treturn amtOut.add(_ethToEthtx(basePrice, amtOver));\n\t\t\t\t}\n\t\t\t\treturn _ethToEthtx(basePrice.mul(2), amountETHIn);\n\t\t\t}\n\n\t\t\treturn _ethToEthtx(basePrice, amountETHIn);\n\t\t}\n\n\t\tuint256 ethTarget;\n\t\t{\n\t\t\t(uint256 cTargetNum, uint256 cTargetDen) = ammHandle.targetCRatio();\n\t\t\tethTarget = liability.mul(cTargetNum).div(cTargetDen);\n\t\t}\n\n\t\tif (collat < ethTarget) {\n\t\t\tuint256 ethEnd = collat.add(amountETHIn);\n\t\t\tif (ethEnd <= ethTarget) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tamountETHIn = ethEnd - ethTarget;\n\t\t\tcollat = ethTarget;\n\t\t}\n\n\t\tuint256 firstTerm = basePrice.mul(amountETHIn);\n\n\t\tuint256 collatDiff = collat - liability;\n\t\tuint256 coeffA = lambda_.mul(liability).mul(gasPrice);\n\n\t\tuint256 secondTerm =\n\t\t\tbasePrice.mul(collatDiff).add(coeffA).mul(1e18).ln().mul(coeffA);\n\t\tsecondTerm /= 1e18;\n\n\t\tuint256 thirdTerm = basePrice.mul(collatDiff.add(amountETHIn));\n\t\t// avoids stack too deep error\n\t\tthirdTerm = thirdTerm.add(coeffA).mul(1e18).ln().mul(coeffA) / 1e18;\n\n\t\tuint256 numerator = firstTerm.add(secondTerm).sub(thirdTerm).mul(1e18);\n\t\tuint256 denominator = _GAS_PER_ETHTX.mul(basePrice).mul(basePrice);\n\t\treturn numerator.div(denominator);\n\t}\n\n\tfunction inGenesis() external view virtual override returns (bool) {\n\t\treturn _inGenesis;\n\t}\n\n\tfunction numLiquidityPools()\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _lps.length();\n\t}\n\n\tfunction liquidityPoolsAt(uint256 index)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _lps.at(index);\n\t}\n\n\tfunction lpRecipient() public view virtual override returns (address) {\n\t\treturn _lpRecipient;\n\t}\n\n\tfunction lpShare()\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint128 numerator, uint128 denominator)\n\t{\n\t\tnumerator = _lpShareNum;\n\t\tdenominator = _lpShareDen;\n\t}\n\n\tfunction totalGiven() public view virtual override returns (uint256) {\n\t\treturn _totalGiven;\n\t}\n\n\tfunction weth() public view virtual override returns (address) {\n\t\treturn _weth;\n\t}\n\n\t/* Internal Views */\n\n\tfunction _ethmxCurve(uint256 amountETHIn, ETHmxMintParams memory mp)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\tuint256 cRatioNum;\n\t\tuint256 cRatioDen;\n\t\tuint256 cTargetNum;\n\t\tuint256 cTargetDen;\n\t\t{\n\t\t\tIETHtxAMM ammHandle = IETHtxAMM(_ethtxAMM);\n\t\t\t(cRatioNum, cRatioDen) = ammHandle.cRatio();\n\n\t\t\tif (cRatioDen == 0) {\n\t\t\t\t// cRatio > cCap\n\t\t\t\treturn amountETHIn.mul(mp.zetaFloorNum).div(mp.zetaFloorDen);\n\t\t\t}\n\n\t\t\t(cTargetNum, cTargetDen) = ammHandle.targetCRatio();\n\t\t}\n\n\t\tuint256 ethEnd = cRatioNum.add(amountETHIn);\n\t\tuint256 ethTarget = cRatioDen.mul(cTargetNum).div(cTargetDen);\n\t\tuint256 ethCap = cRatioDen.mul(mp.cCapNum).div(mp.cCapDen);\n\t\tif (cRatioNum >= ethCap) {\n\t\t\t// cRatio >= cCap\n\t\t\treturn amountETHIn.mul(mp.zetaFloorNum).div(mp.zetaFloorDen);\n\t\t}\n\n\t\tif (cRatioNum < ethTarget) {\n\t\t\t// cRatio < cTarget\n\t\t\tif (ethEnd > ethCap) {\n\t\t\t\t// Add definite integral\n\t\t\t\tuint256 curveAmt =\n\t\t\t\t\t_ethmxDefiniteIntegral(\n\t\t\t\t\t\tethCap - ethTarget,\n\t\t\t\t\t\tmp,\n\t\t\t\t\t\tcTargetNum,\n\t\t\t\t\t\tcTargetDen,\n\t\t\t\t\t\tethTarget,\n\t\t\t\t\t\tcRatioDen\n\t\t\t\t\t);\n\n\t\t\t\t// Add amount past cap\n\t\t\t\tuint256 pastCapAmt =\n\t\t\t\t\t(ethEnd - ethCap).mul(mp.zetaFloorNum).div(mp.zetaFloorDen);\n\n\t\t\t\t// add initial amount\n\t\t\t\tuint256 flatAmt =\n\t\t\t\t\t(ethTarget - cRatioNum).mul(mp.zetaCeilNum).div(mp.zetaCeilDen);\n\n\t\t\t\treturn flatAmt.add(curveAmt).add(pastCapAmt);\n\t\t\t} else if (ethEnd > ethTarget) {\n\t\t\t\t// Add definite integral for partial amount\n\t\t\t\tuint256 ethOver = ethEnd - ethTarget;\n\t\t\t\tuint256 curveAmt =\n\t\t\t\t\t_ethmxDefiniteIntegral(\n\t\t\t\t\t\tethOver,\n\t\t\t\t\t\tmp,\n\t\t\t\t\t\tcTargetNum,\n\t\t\t\t\t\tcTargetDen,\n\t\t\t\t\t\tethTarget,\n\t\t\t\t\t\tcRatioDen\n\t\t\t\t\t);\n\n\t\t\t\tuint256 ethBeforeCurve = amountETHIn - ethOver;\n\t\t\t\tuint256 flatAmt =\n\t\t\t\t\tethBeforeCurve.mul(mp.zetaCeilNum).div(mp.zetaCeilDen);\n\t\t\t\treturn flatAmt.add(curveAmt);\n\t\t\t}\n\n\t\t\treturn amountETHIn.mul(mp.zetaCeilNum).div(mp.zetaCeilDen);\n\t\t}\n\n\t\t// cTarget < cRatio < cCap\n\t\tif (ethEnd > ethCap) {\n\t\t\tuint256 ethOver = ethEnd - ethCap;\n\t\t\tuint256 curveAmt =\n\t\t\t\t_ethmxDefiniteIntegral(\n\t\t\t\t\tamountETHIn - ethOver,\n\t\t\t\t\tmp,\n\t\t\t\t\tcTargetNum,\n\t\t\t\t\tcTargetDen,\n\t\t\t\t\tcRatioNum,\n\t\t\t\t\tcRatioDen\n\t\t\t\t);\n\n\t\t\tuint256 flatAmt = ethOver.mul(mp.zetaFloorNum).div(mp.zetaFloorDen);\n\n\t\t\treturn curveAmt.add(flatAmt);\n\t\t}\n\n\t\treturn\n\t\t\t_ethmxDefiniteIntegral(\n\t\t\t\tamountETHIn,\n\t\t\t\tmp,\n\t\t\t\tcTargetNum,\n\t\t\t\tcTargetDen,\n\t\t\t\tcRatioNum,\n\t\t\t\tcRatioDen\n\t\t\t);\n\t}\n\n\tfunction _ethmxDefiniteIntegral(\n\t\tuint256 amountETHIn,\n\t\tETHmxMintParams memory mp,\n\t\tuint256 cTargetNum,\n\t\tuint256 cTargetDen,\n\t\tuint256 initCollateral,\n\t\tuint256 liability\n\t) internal pure virtual returns (uint256) {\n\t\tuint256 fctMulNum = mp.zetaFloorNum.mul(mp.zetaCeilDen).mul(cTargetDen);\n\t\tuint256 fctMulDen = mp.zetaFloorDen.mul(mp.zetaCeilNum).mul(cTargetNum);\n\n\t\t// prettier-ignore\n\t\tuint256 first =\n\t\t\tamountETHIn\n\t\t\t.mul(fctMulNum.mul(mp.cCapNum))\n\t\t\t.div(fctMulDen.mul(mp.cCapDen));\n\n\t\tuint256 second = amountETHIn.mul(mp.zetaFloorNum).div(mp.zetaFloorDen);\n\n\t\tuint256 tNum = fctMulNum.mul(amountETHIn);\n\t\tuint256 tDen = fctMulDen.mul(2).mul(liability);\n\t\tuint256 third = initCollateral.mul(2).add(amountETHIn);\n\t\t// avoids stack too deep error\n\t\tthird = third.mul(tNum).div(tDen);\n\n\t\treturn first.add(second).sub(third);\n\t}\n\n\tfunction _ethToEthtx(uint256 gasPrice, uint256 amountETH)\n\t\tinternal\n\t\tpure\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\trequire(gasPrice != 0, \"ETHmxMinter: gasPrice is zero\");\n\t\treturn amountETH.mul(1e18) / gasPrice.mul(_GAS_PER_ETHTX);\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\tIETHmx(ethmx()).mintTo(account, amount);\n\t}\n\n\tfunction _mintEthtx(uint256 amountEthIn) internal virtual {\n\t\t// Mint ETHtx.\n\t\tuint256 ethtxToMint = ethtxFromEth(amountEthIn);\n\n\t\tif (ethtxToMint == 0) {\n\t\t\treturn;\n\t\t}\n\n\t\taddress ethtx_ = ethtx();\n\t\tIETHtx(ethtx_).mint(address(this), ethtxToMint);\n\n\t\t// Lock portion into liquidity in designated pools\n\t\t(uint256 ethtxSentToLp, uint256 ethSentToLp) = _sendToLps(ethtxToMint);\n\n\t\t// Send the rest to the AMM.\n\t\taddress ethtxAmm_ = ethtxAMM();\n\t\tIERC20(weth()).safeTransfer(ethtxAmm_, amountEthIn.sub(ethSentToLp));\n\t\tIERC20(ethtx_).safeTransfer(ethtxAmm_, ethtxToMint.sub(ethtxSentToLp));\n\t}\n\n\tfunction _sendToLps(uint256 ethtxTotal)\n\t\tinternal\n\t\tvirtual\n\t\treturns (uint256 totalEthtxSent, uint256 totalEthSent)\n\t{\n\t\tuint256 numLps = _lps.length();\n\t\tif (numLps == 0) {\n\t\t\treturn (0, 0);\n\t\t}\n\n\t\t(uint256 lpShareNum, uint256 lpShareDen) = lpShare();\n\t\tif (lpShareNum == 0) {\n\t\t\treturn (0, 0);\n\t\t}\n\n\t\tuint256 ethtxToLp = ethtxTotal.mul(lpShareNum).div(lpShareDen).div(numLps);\n\t\tuint256 ethToLp = IETHtxAMM(ethtxAMM()).ethToExactEthtx(ethtxToLp);\n\t\taddress ethtx_ = ethtx();\n\t\taddress weth_ = weth();\n\t\taddress to = lpRecipient();\n\n\t\tfor (uint256 i = 0; i < numLps; i++) {\n\t\t\taddress pool = _lps.at(i);\n\n\t\t\tIERC20(ethtx_).safeIncreaseAllowance(pool, ethtxToLp);\n\t\t\tIERC20(weth_).safeIncreaseAllowance(pool, ethToLp);\n\n\t\t\t(uint256 ethtxSent, uint256 ethSent, ) =\n\t\t\t\tIPool(pool).addLiquidity(\n\t\t\t\t\tethtx_,\n\t\t\t\t\tweth_,\n\t\t\t\t\tethtxToLp,\n\t\t\t\t\tethToLp,\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\tto,\n\t\t\t\t\t// solhint-disable-next-line not-rely-on-time\n\t\t\t\t\tblock.timestamp\n\t\t\t\t);\n\n\t\t\ttotalEthtxSent = totalEthtxSent.add(ethtxSent);\n\t\t\ttotalEthSent = totalEthSent.add(ethSent);\n\t\t}\n\t}\n}\n"
    },
    "contracts/exchanges/ETHmxMinter/ETHmxMinterData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\nimport \"../interfaces/IETHmxMinter.sol\";\n\nabstract contract ETHmxMinterData {\n\taddress internal _ethmx;\n\taddress internal _ethtx;\n\taddress internal _ethtxAMM;\n\taddress internal _weth;\n\n\t// ETHmx minting\n\tuint256 internal _totalGiven;\n\tIETHmxMinter.ETHmxMintParams internal _ethmxMintParams;\n\n\t// ETHtx minting\n\tuint128 internal _minMintPrice;\n\tuint64 internal _mu;\n\tuint64 internal _lambda;\n\n\t// Liquidity pool distribution\n\tuint128 internal _lpShareNum;\n\tuint128 internal _lpShareDen;\n\tEnumerableSet.AddressSet internal _lps;\n\taddress internal _lpRecipient;\n\n\tbool internal _inGenesis;\n\n\tuint256[39] private __gap;\n}\n"
    },
    "contracts/exchanges/interfaces/IETHmxMinter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\ninterface IETHmxMinter {\n\t/* Types */\n\n\tstruct ETHmxMintParams {\n\t\t// Uses a single 32 byte slot and avoids stack too deep errors\n\t\tuint32 cCapNum;\n\t\tuint32 cCapDen;\n\t\tuint32 zetaFloorNum;\n\t\tuint32 zetaFloorDen;\n\t\tuint32 zetaCeilNum;\n\t\tuint32 zetaCeilDen;\n\t}\n\n\tstruct ETHtxMintParams {\n\t\tuint128 minMintPrice;\n\t\tuint64 mu;\n\t\tuint64 lambda;\n\t}\n\n\t/* Views */\n\n\tfunction ethmx() external view returns (address);\n\n\tfunction ethmxMintParams() external view returns (ETHmxMintParams memory);\n\n\tfunction ethmxFromEth(uint256 amountETHIn) external view returns (uint256);\n\n\tfunction ethmxFromEthtx(uint256 amountETHtxIn)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\tfunction ethtx() external view returns (address);\n\n\tfunction ethtxMintParams() external view returns (ETHtxMintParams memory);\n\n\tfunction ethtxAMM() external view returns (address);\n\n\tfunction ethtxFromEth(uint256 amountETHIn) external view returns (uint256);\n\n\tfunction inGenesis() external view returns (bool);\n\n\tfunction numLiquidityPools() external view returns (uint256);\n\n\tfunction liquidityPoolsAt(uint256 index) external view returns (address);\n\n\tfunction lpRecipient() external view returns (address);\n\n\tfunction lpShare()\n\t\texternal\n\t\tview\n\t\treturns (uint128 numerator, uint128 denominator);\n\n\tfunction totalGiven() external view returns (uint256);\n\n\tfunction weth() external view returns (address);\n\n\t/* Mutators */\n\n\tfunction addLp(address pool) external;\n\n\tfunction mint() external payable;\n\n\tfunction mintWithETHtx(uint256 amountIn) external;\n\n\tfunction mintWithWETH(uint256 amountIn) external;\n\n\tfunction pause() external;\n\n\tfunction recoverERC20(\n\t\taddress token,\n\t\taddress to,\n\t\tuint256 amount\n\t) external;\n\n\tfunction removeLp(address pool) external;\n\n\tfunction setEthmx(address addr) external;\n\n\tfunction setEthmxMintParams(ETHmxMintParams memory mp) external;\n\n\tfunction setEthtxMintParams(ETHtxMintParams memory mp) external;\n\n\tfunction setEthtx(address addr) external;\n\n\tfunction setEthtxAMM(address addr) external;\n\n\tfunction setLpRecipient(address account) external;\n\n\tfunction setLpShare(uint128 numerator, uint128 denominator) external;\n\n\tfunction setWeth(address addr) external;\n\n\tfunction unpause() external;\n\n\t/* Events */\n\n\tevent EthmxSet(address indexed author, address indexed addr);\n\tevent EthmxMintParamsSet(address indexed author, ETHmxMintParams mp);\n\tevent EthtxMintParamsSet(address indexed author, ETHtxMintParams mp);\n\tevent EthtxSet(address indexed author, address indexed addr);\n\tevent EthtxAMMSet(address indexed author, address indexed addr);\n\tevent LpAdded(address indexed author, address indexed account);\n\tevent LpRecipientSet(address indexed author, address indexed account);\n\tevent LpRemoved(address indexed author, address indexed account);\n\tevent LpShareSet(\n\t\taddress indexed author,\n\t\tuint128 numerator,\n\t\tuint128 denominator\n\t);\n\tevent Recovered(\n\t\taddress indexed author,\n\t\taddress indexed token,\n\t\taddress indexed to,\n\t\tuint256 amount\n\t);\n\tevent WethSet(address indexed author, address indexed addr);\n}\n"
    },
    "contracts/libraries/UintLog.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nlibrary UintLog {\n\tuint256 internal constant _LOG2_E = 1442695040888963407;\n\n\tfunction ln(uint256 x) internal pure returns (uint256) {\n\t\treturn (blog2(x) * 1e18) / _LOG2_E;\n\t}\n\n\t// Most significant bit\n\t// prettier-ignore\n\tfunction msb(uint256 x) internal pure returns (uint256 n) {\n\t\tif (x >= 0x100000000000000000000000000000000) { x >>= 128; n += 128; }\n\t\tif (x >= 0x10000000000000000) { x >>= 64; n += 64; }\n\t\tif (x >= 0x100000000) { x >>= 32; n += 32; }\n\t\tif (x >= 0x10000) { x >>= 16; n += 16; }\n\t\tif (x >= 0x100) { x >>= 8; n += 8; }\n\t\tif (x >= 0x10) { x >>= 4; n += 4; }\n\t\tif (x >= 0x4) { x >>= 2; n += 2; }\n\t\tif (x >= 0x2) { /* x >>= 1; */ n += 1; }\n\t}\n\n\t// Approximate binary log of uint\n\t// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n\t// https://github.com/hifi-finance/prb-math/blob/5c6817860496ec40fd269934f3c531822402f1ce/contracts/PRBMathUD60x18.sol#L334-L380\n\tfunction blog2(uint256 x) internal pure returns (uint256 result) {\n\t\trequire(x >= 1e18, \"blog2 too small\");\n\t\tuint256 n = msb(x / 1e18);\n\n\t\tresult = n * 1e18;\n\t\tuint256 y = x >> n;\n\n\t\tif (y == 1e18) {\n\t\t\treturn result;\n\t\t}\n\n\t\tfor (uint256 delta = 5e17; delta > 0; delta >>= 1) {\n\t\t\ty = (y * y) / 1e18;\n\t\t\tif (y >= 2e18) {\n\t\t\t\tresult += delta;\n\t\t\t\ty >>= 1;\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/exchanges/mocks/MockETHmxMinter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\npragma abicoder v2;\n\nimport \"../ETHmxMinter/ETHmxMinter.sol\";\n\ncontract MockETHmxMinter is ETHmxMinter {\n\tconstructor(address owner_) ETHmxMinter(owner_) {\n\t\treturn;\n\t}\n\n\tfunction setInGenesis(bool val) external {\n\t\t_inGenesis = val;\n\t}\n}\n"
    },
    "contracts/libraries/mocks/MockUintLog.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"../UintLog.sol\";\n\ncontract MockUintLog {\n\tusing UintLog for uint256;\n\n\tfunction ln(uint256 x) external pure returns (uint256) {\n\t\treturn x.ln();\n\t}\n\n\tfunction blog2(uint256 x) external pure returns (uint256) {\n\t\treturn x.blog2();\n\t}\n}\n"
    },
    "contracts/access/AccessControl/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * From https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/aeb86bf4f438e0fedb5eecc3dd334fd6544ab1f6/contracts/access/AccessControlUpgradeable.sol\n *\n * Changes:\n * - Compiled for 0.7.6\n * - Removed ERC165 Introspection\n * - Moved state to AccessControlData\n * - Removed _checkRole\n * - Reformatted styling in line with this repository.\n */\n\n/*\nThe MIT License (MIT)\n\nCopyright (c) 2016-2020 zOS Global Limited\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/Initializable.sol\";\n\nimport \"./AccessControlData.sol\";\nimport \"../interfaces/IAccessControl.sol\";\n\n/* solhint-disable func-name-mixedcase */\n\npragma solidity 0.7.6;\n\nabstract contract AccessControlUpgradeable is\n\tInitializable,\n\tContextUpgradeable,\n\tAccessControlData,\n\tIAccessControl\n{\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\t/* Initializer */\n\n\tfunction __AccessControl_init() internal initializer {\n\t\t__Context_init_unchained();\n\t}\n\n\tfunction __AccessControl_init_unchained() internal initializer {\n\t\treturn;\n\t}\n\n\t/* Modifiers */\n\n\tmodifier onlyRole(bytes32 role) {\n\t\trequire(hasRole(role, _msgSender()), \"AccessControl: access denied\");\n\t\t_;\n\t}\n\n\t/* External Views */\n\n\tfunction hasRole(bytes32 role, address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _roles[role].members[account];\n\t}\n\n\tfunction getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n\t\treturn _roles[role].adminRole;\n\t}\n\n\t/* External Mutators */\n\n\tfunction grantRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_grantRole(role, account);\n\t}\n\n\tfunction revokeRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_revokeRole(role, account);\n\t}\n\n\tfunction renounceRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(\n\t\t\taccount == _msgSender(),\n\t\t\t\"AccessControl: can only renounce roles for self\"\n\t\t);\n\n\t\t_revokeRole(role, account);\n\t}\n\n\t/* Internal Mutators */\n\n\tfunction _setupRole(bytes32 role, address account) internal virtual {\n\t\t_grantRole(role, account);\n\t}\n\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\t\temit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n\t\t_roles[role].adminRole = adminRole;\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) private {\n\t\tif (!hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) private {\n\t\tif (hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t}\n\t}\n}\n"
    },
    "contracts/access/AccessControl/AccessControlData.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nabstract contract AccessControlData {\n\tstruct RoleData {\n\t\tmapping(address => bool) members;\n\t\tbytes32 adminRole;\n\t}\n\n\tmapping(bytes32 => RoleData) internal _roles;\n\n\tuint256[49] private __gap;\n}\n"
    },
    "contracts/rewards/mooniswap/MooniFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * From https://github.com/1inch-exchange/mooniswap/blob/v1.0/contracts/MooniFactory.sol\n * This is used exclusively for testing.\n * Changes:\n * - Updated from solidity ^0.6.0 to ^0.7.0.\n * - Reformatted styling in line with this repository.\n */\n\n/*\nMIT License\n\nCopyright (c) 2020 Mooniswap\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./UniERC20.sol\";\nimport \"./Mooniswap.sol\";\n\ncontract MooniFactory is Ownable {\n\tusing UniERC20 for IERC20;\n\n\tevent Deployed(\n\t\taddress indexed mooniswap,\n\t\taddress indexed token1,\n\t\taddress indexed token2\n\t);\n\n\tuint256 public constant MAX_FEE = 0.003e18; // 0.3%\n\n\tuint256 public fee;\n\tMooniswap[] public allPools;\n\tmapping(Mooniswap => bool) public isPool;\n\tmapping(IERC20 => mapping(IERC20 => Mooniswap)) public pools;\n\n\tfunction getAllPools() external view returns (Mooniswap[] memory) {\n\t\treturn allPools;\n\t}\n\n\tfunction setFee(uint256 newFee) external onlyOwner {\n\t\trequire(newFee <= MAX_FEE, \"Factory: fee should be <= 0.3%\");\n\t\tfee = newFee;\n\t}\n\n\tfunction deploy(IERC20 tokenA, IERC20 tokenB)\n\t\tpublic\n\t\treturns (Mooniswap pool)\n\t{\n\t\trequire(tokenA != tokenB, \"Factory: not support same tokens\");\n\t\trequire(\n\t\t\tpools[tokenA][tokenB] == Mooniswap(0),\n\t\t\t\"Factory: pool already exists\"\n\t\t);\n\n\t\t(IERC20 token1, IERC20 token2) = sortTokens(tokenA, tokenB);\n\t\tIERC20[] memory tokens = new IERC20[](2);\n\t\ttokens[0] = token1;\n\t\ttokens[1] = token2;\n\n\t\tstring memory symbol1 = token1.uniSymbol();\n\t\tstring memory symbol2 = token2.uniSymbol();\n\n\t\tpool = new Mooniswap(\n\t\t\ttokens,\n\t\t\tstring(abi.encodePacked(\"Mooniswap V1 (\", symbol1, \"-\", symbol2, \")\")),\n\t\t\tstring(abi.encodePacked(\"MOON-V1-\", symbol1, \"-\", symbol2))\n\t\t);\n\n\t\tpool.transferOwnership(owner());\n\t\tpools[token1][token2] = pool;\n\t\tpools[token2][token1] = pool;\n\t\tallPools.push(pool);\n\t\tisPool[pool] = true;\n\n\t\temit Deployed(address(pool), address(token1), address(token2));\n\t}\n\n\tfunction sortTokens(IERC20 tokenA, IERC20 tokenB)\n\t\tpublic\n\t\tpure\n\t\treturns (IERC20, IERC20)\n\t{\n\t\tif (tokenA < tokenB) {\n\t\t\treturn (tokenA, tokenB);\n\t\t}\n\t\treturn (tokenB, tokenA);\n\t}\n}\n"
    },
    "contracts/rewards/ValuePerMoonV1.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Copyright 2021 weiWard LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npragma solidity 0.7.6;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/IValuePerToken.sol\";\n\ninterface IMooniswap {\n\tfunction totalSupply() external view returns (uint256);\n\n\tfunction getTokens() external view returns (address[] memory);\n}\n\ncontract ValuePerMoonV1 is IValuePerToken {\n\t/* Immutable Public State */\n\n\taddress public immutable override token;\n\taddress public immutable valueToken;\n\n\t/* Constructor */\n\n\tconstructor(address _token, address _valueToken) {\n\t\tbool hasToken = false;\n\t\taddress[] memory tokens = IMooniswap(_token).getTokens();\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\tif (_valueToken == tokens[i]) {\n\t\t\t\thasToken = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trequire(hasToken, \"ValuePerMoonV1: pool lacks token\");\n\n\t\ttoken = _token;\n\t\tvalueToken = _valueToken;\n\t}\n\n\t/* External Views */\n\n\tfunction valuePerToken()\n\t\texternal\n\t\tview\n\t\toverride\n\t\treturns (uint256 numerator, uint256 denominator)\n\t{\n\t\tdenominator = IMooniswap(token).totalSupply();\n\n\t\taddress[] memory tokens = IMooniswap(token).getTokens();\n\t\tfor (uint256 i = 0; i < tokens.length; i++) {\n\t\t\taddress pairToken = tokens[i];\n\t\t\tif (valueToken != pairToken) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnumerator = IERC20(pairToken).balanceOf(token);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}